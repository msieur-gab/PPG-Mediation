<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rhythm Breath - Heart Rate Based Meditation</title>
  <style>
    /* Base styles */
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f3f4f6;
      color: #374151;
    }
    
    .container {
      max-width: 480px;
      margin: 0 auto;
      padding: 24px;
    }
    
    .hidden {
      display: none !important;
    }
    
    /* Header */
    .header {
      text-align: center;
      margin-bottom: 24px;
    }
    
    .app-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: #4f46e5;
      margin-bottom: 8px;
    }
    
    .app-subtitle {
      color: #6b7280;
      font-size: 0.9rem;
      margin-top: 0;
    }
    
    /* Main card */
    .card {
      background-color: white;
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin-bottom: 24px;
      text-align: center;
    }
    
    /* Camera section */
    .camera-icon {
      background-color: #fee2e2;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 16px auto;
    }
    
    .camera-instruction {
      margin-bottom: 16px;
    }
    
    .camera-toggle, .flash-toggle { /* Added .flash-toggle */
      background: none;
      border: none;
      color: #4f46e5;
      font-size: 0.875rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      margin: 8px auto 16px auto; /* Adjusted margin for multiple toggles */
    }
    
    .camera-toggle svg, .flash-toggle svg { /* Added .flash-toggle */
      margin-right: 4px;
    }
    
    .camera-error {
      color: #ef4444;
      font-size: 0.875rem;
      margin-bottom: 16px;
    }
    
    /* Camera preview */
    .preview-container {
      position: relative;
      width: 128px;
      height: 128px;
      margin: 0 auto 16px auto;
    }
    
    .camera-preview {
      width: 128px;
      height: 128px;
      border-radius: 8px;
      border: 2px solid #f87171;
      object-fit: cover;
    }
    
    .preview-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .preview-help {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 4px;
    }
    
    /* Countdown */
    .countdown {
      width: 64px;
      height: 64px;
      background-color: #ef4444;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 700;
      font-size: 1.25rem;
      margin: 0 auto 8px auto;
    }
    
    .countdown.pulse {
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(0.95);
        box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
      }
      
      70% {
        transform: scale(1);
        box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
      }
      
      100% {
        transform: scale(0.95);
        box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
      }
    }
    
    .keep-steady {
      margin-bottom: 8px;
    }
    
    /* Measurement indicators */
    .measurement-indicators {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 8px;
    }
    
    .indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: #d1d5db; /* Default gray */
    }
    
    .indicator.active {
      background-color: #ef4444; /* Red for active */
      animation: pulse 1.5s infinite;
    }
    
    .indicator.complete {
      background-color: #10b981; /* Green for complete */
    }

    .indicator.failed {
      background-color: #f59e0b; /* Amber/Orange for failed */
    }
    
    /* Readings display */
    .readings {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-top: 12px;
      font-size: 0.75rem;
    }
    
    .reading {
      display: flex;
      align-items: center;
    }
    
    .reading-value {
      font-weight: 500;
    }
    
    .reading-unit {
      color: #6b7280;
    }
    
    /* Signal visualization */
    .visualization {
      height: 64px;
      width: 100%;
      background-color: #f3f4f6;
      position: relative;
      overflow: hidden;
      margin-top: 16px;
    }
    
    .visualization-bar {
      position: absolute;
      bottom: 0;
      width: 4px;
      background-color: #ef4444;
      opacity: 0.7;
    }
    
    /* Results */
    .heart-rate {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 8px;
    }
    
    .heart-rate-value {
      font-size: 1.5rem;
      font-weight: 700;
      margin-left: 8px;
    }
    
    .result-readings {
      display: flex;
      justify-content: center;
      flex-wrap: wrap; /* Allow readings to wrap if many */
      margin-bottom: 16px;
      font-size: 0.875rem;
    }
    
    .result-reading {
      margin: 0 8px;
      display: flex;
      align-items: center;
    }
    
    .tempo-box {
      background-color: #eef2ff;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 16px;
    }
    
    .tempo-value {
      font-weight: 700;
    }
    
    .tempo-note {
      font-size: 0.875rem;
      color: #6b7280;
      margin-top: 4px;
    }
    
    /* Buttons */
    .btn {
      padding: 8px 24px;
      border-radius: 8px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s ease;
      border: none;
      display: inline-flex;
      align-items: center;
      margin-top: 8px; /* Added some top margin for spacing */
    }
    
    .btn-primary {
      background-color: #4f46e5;
      color: white;
    }
    
    .btn-primary:hover {
      background-color: #4338ca;
    }
    
    .btn-success {
      background-color: #10b981;
      color: white;
    }
    
    .btn-success:hover {
      background-color: #059669;
    }
     .btn-success.btn-disabled {
      background-color: #a0aec0; /* Example disabled color */
      cursor: not-allowed;
      opacity: 0.7;
    }
    
    .btn-danger {
      background-color: #ef4444;
      color: white;
    }
    
    .btn-danger:hover {
      background-color: #dc2626;
    }
    
    .btn-link {
      background: none;
      color: #4f46e5;
      padding: 0;
    }
    
    .btn-link:hover {
      color: #4338ca;
    }
    
    .btn svg {
      margin-right: 4px;
    }
    
    /* Meditation progress */
    .meditation-section {
      margin-bottom: 24px;
    }
    
    .progress-bar {
      height: 12px;
      background-color: #e5e7eb;
      border-radius: 999px;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background-color: #10b981;
      transition: width 0.3s ease-out;
    }
    
    .progress-times {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 4px;
    }
    
    .current-track {
      font-size: 0.875rem;
      color: #6b7280;
      margin-top: 8px;
    }
    
    .track-name {
      font-weight: 500;
    }
    
    /* Info box */
    .info-box {
      background-color: #eef2ff;
      padding: 16px;
      border-radius: 8px;
    }
    
    .info-title {
      font-weight: 600;
      color: #1e40af;
      margin-top: 0;
      margin-bottom: 8px;
    }
    
    .info-text {
      font-size: 0.875rem;
      color: #4b5563;
      margin: 0;
    }

    /* Icons */
    .icon {
      display: inline-block;
      width: 24px;
      height: 24px;
      stroke-width: 2;
      stroke: currentColor;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    
    .icon-sm {
      width: 16px;
      height: 16px;
    }
    
    .icon-xs {
      width: 12px;
      height: 12px;
    }
    
    .icon-lg {
      width: 48px;
      height: 48px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1 class="app-title">Rhythm Breath</h1>
      <p class="app-subtitle">Personalized meditation based on your heart rhythm</p>
    </div>
    
    <div class="hidden">
      <video id="processingVideo" playsinline muted></video>
      <canvas id="processingCanvas"></canvas>
    </div>
    
    <div class="card" id="mainCard">
      <div id="initialState">
        <div class="camera-icon">
          <svg class="icon icon-lg" viewBox="0 0 24 24">
            <rect x="2" y="6" width="20" height="12" rx="2" ry="2"></rect>
            <circle cx="12" cy="12" r="3"></circle>
          </svg>
        </div>
        <p class="camera-instruction">Place your thumb over your camera lens to measure your heart rate</p>
        
        <button id="cameraToggle" class="camera-toggle hidden">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <path d="M23 4v6h-6"></path>
            <path d="M1 20v-6h6"></path>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
            <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
          </svg>
          Switch to front camera
        </button>
        
        <div id="cameraError" class="camera-error hidden"></div>
        
        <button id="startMeasurementBtn" class="btn btn-primary">Start Measurement</button>
      </div>
      
      <div id="measuringState" class="hidden">
        <div class="preview-container" id="previewContainer">
          <video id="previewVideo" class="camera-preview" playsinline muted autoplay></video>
          <canvas id="previewCanvas" class="preview-overlay" width="128" height="128"></canvas>
          <div class="preview-help">Center your fingertip in the red box</div>
        </div>

        <button id="flashToggleBtn" class="flash-toggle btn btn-link hidden">
            <svg class="icon icon-sm" viewBox="0 0 24 24" id="flashIcon">
                <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon> </svg>
            <span id="flashToggleText">Turn Flash On</span>
        </button>
        
        <div id="countdown" class="countdown pulse">5</div>
        <p class="keep-steady">Keep your thumb steady...</p>
        
        <div class="measurement-indicators" id="measurementIndicators">
          <div class="indicator"></div>
          <div class="indicator"></div>
          <div class="indicator"></div>
        </div>
        
        <div id="readings" class="readings"></div>
        
        <div id="visualization" class="visualization"></div>
      </div>
      
      <div id="resultsState" class="hidden">
        <div class="heart-rate">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M22 12h-4l-3 9L9 3l-3 9H2"></path>
          </svg>
          <span id="heartRateValue" class="heart-rate-value">72 BPM</span>
        </div>
        
        <div id="resultReadings" class="result-readings"></div>
        
        <div class="tempo-box">
          <p>Recommended music tempo: <span id="tempoValue" class="tempo-value">60 BPM</span></p>
          <p class="tempo-note">Music at this tempo will help guide your heart rate toward a more relaxed state</p>
        </div>
        
        <button id="remeasureBtn" class="btn btn-link">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <path d="M23 4v6h-6"></path>
            <path d="M1 20v-6h6"></path>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
            <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
          </svg>
          Re-measure
        </button>
        
        <button id="startSessionBtn" class="btn btn-success">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
          </svg>
          Start Session
        </button>
        
        <button id="endSessionBtn" class="btn btn-danger hidden">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <rect x="6" y="4" width="4" height="16"></rect>
            <rect x="14" y="4" width="4" height="16"></rect>
          </svg>
          End Session
        </button>
      </div>
    </div>
    
    <div id="meditationSection" class="meditation-section hidden">
      <div class="progress-bar">
        <div id="progressFill" class="progress-fill" style="width: 0%"></div>
      </div>
      <div class="progress-times">
        <span>0:00</span>
        <span>10:00</span>
      </div>
      <p class="current-track">
        Currently playing: <span class="track-name">Ocean Calm</span> (<span id="currentTempo">60</span> BPM)
      </p>
    </div>
    
    <div class="info-box">
      <h3 class="info-title">How it works</h3>
      <p class="info-text">
        We use your device's camera to capture subtle color changes in your fingertip
        that correspond to your pulse. We take 3 measurements to ensure accuracy,
        extract the red channel data, analyze the waveform to detect peaks,
        and calculate your heart rate. Then we generate meditation music with a 
        tempo designed to guide you toward a more peaceful state.
      </p>
    </div>
  </div>

  <script>
    // Configuration
    const FPS = 30;
    const MEASUREMENT_DURATION = 8; // seconds
    const BUFFER_SIZE = FPS * MEASUREMENT_DURATION;
    const TOTAL_MEASUREMENTS = 3;
    const FAILED_MEASUREMENT_TEXT = "Failed"; 
    const SMOOTHING_WINDOW_SIZE = 7; // Increased smoothing window
    const MIN_PEAK_INTERVAL_FRAMES = Math.round(FPS * (60 / 200)); // Min interval for 200 BPM
    const MAX_PEAK_INTERVAL_FRAMES = Math.round(FPS * (60 / 40));  // Max interval for 40 BPM


    // State variables
    let measuring = false;
    let heartRate = null;
    let recommendedTempo = null;
    let countdown = 5;
    let meditationActive = false;
    let progress = 0;
    let dataPoints = [];
    let stream = null;
    let measurementNumber = 0;
    let individualReadings = []; 
    let cameraFacing = 'environment'; 
    let availableCameras = [];
    let flashSupported = false; 
    let flashActive = false;    
    
    // References to DOM elements
    const initialState = document.getElementById('initialState');
    const measuringState = document.getElementById('measuringState');
    const resultsState = document.getElementById('resultsState');
    const meditationSection = document.getElementById('meditationSection');
    
    const processingVideo = document.getElementById('processingVideo');
    const processingCanvas = document.getElementById('processingCanvas');
    const previewVideo = document.getElementById('previewVideo');
    const previewCanvas = document.getElementById('previewCanvas');
    
    const startMeasurementBtn = document.getElementById('startMeasurementBtn');
    const cameraToggle = document.getElementById('cameraToggle');
    const cameraError = document.getElementById('cameraError');
    const countdownElement = document.getElementById('countdown');
    const measurementIndicators = document.getElementById('measurementIndicators');
    const readings = document.getElementById('readings');
    const visualization = document.getElementById('visualization');
    
    const heartRateValue = document.getElementById('heartRateValue');
    const resultReadings = document.getElementById('resultReadings');
    const tempoValue = document.getElementById('tempoValue');
    const remeasureBtn = document.getElementById('remeasureBtn');
    const startSessionBtn = document.getElementById('startSessionBtn');
    const endSessionBtn = document.getElementById('endSessionBtn');
    
    const progressFill = document.getElementById('progressFill');
    const currentTempo = document.getElementById('currentTempo');

    const flashToggleBtn = document.getElementById('flashToggleBtn'); 
    const flashToggleText = document.getElementById('flashToggleText');
    const flashIcon = document.getElementById('flashIcon'); 
    
    // Variables for processing
    let redValuesBuffer = [];
    let frameProcessorId = null;
    let animationId = null; 
    let countdownTimer = null; 
    let singleMeasurementTimer = null; 
    let simulateCountdownTimer = null; 
    let simulateSingleMeasurementTimer = null; 
    let animateSimulatedDataId = null; 


    // Check available cameras on page load
    async function checkCameras() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
        console.error("MediaDevices API or enumerateDevices not supported.");
        showCameraError("Camera features are not supported by your browser or device.");
        availableCameras = []; 
        cameraToggle.classList.add('hidden'); 
        updateCameraToggleText(); 
        return;
      }

      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        availableCameras = devices.filter(device => device.kind === 'videoinput');
        
        if (availableCameras.length > 1) {
          cameraToggle.classList.remove('hidden');
        } else {
          cameraToggle.classList.add('hidden');
        }
        
        if (availableCameras.length === 1) {
            const caps = availableCameras[0].getCapabilities ? availableCameras[0].getCapabilities() : null;
            if (caps && caps.facingMode && Array.isArray(caps.facingMode)) {
                if (caps.facingMode.includes('user')) {
                    cameraFacing = 'user';
                } else if (caps.facingMode.length > 0) {
                    cameraFacing = caps.facingMode[0]; 
                } else {
                    cameraFacing = 'environment'; 
                }
            } else {
                 cameraFacing = 'environment'; 
            }
        } else if (availableCameras.length === 0) {
            console.log("No video input devices found.");
        }
        updateCameraToggleText();
      } catch (error) {
        console.error('Error enumerating devices (raw error object):', error); 
        let userMessage = 'Could not list cameras. Please check browser permissions and ensure your camera is not in use by another app. Measurement may not work.';
        if (error) {
            if (error.name && error.message) userMessage = `Error listing cameras: ${error.name} (${error.message}). Check permissions.`;
            else if (error.name) userMessage = `Error listing cameras: ${error.name}. Check permissions.`;
            else if (typeof error === 'object' && Object.keys(error).length === 0) userMessage = 'An unknown error occurred while trying to list cameras. Please check browser permissions and ensure your camera is not in use. Measurement may not work.';
            else if (typeof error === 'string' && error.length > 0) userMessage = `Error listing cameras: ${error}. Check permissions.`;
        }
        showCameraError(userMessage);
        availableCameras = []; 
        cameraToggle.classList.add('hidden'); 
        updateCameraToggleText(); 
      }
    }
    
    function updateCameraToggleText() {
      cameraToggle.innerHTML = `
        <svg class="icon icon-sm" viewBox="0 0 24 24">
          <path d="M23 4v6h-6"></path>
          <path d="M1 20v-6h6"></path>
          <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
          <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
        </svg>
        Switch to ${cameraFacing === 'environment' ? 'front' : 'back'} camera
      `;
    }
    
    async function toggleCamera() {
      await turnOffFlashIfNeeded(); 
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null; 
      }
      
      cameraFacing = cameraFacing === 'environment' ? 'user' : 'environment';
      updateCameraToggleText();
      flashSupported = false; 
      flashActive = false;
      updateFlashButtonUI(); 
      
      if (measuring) { 
        try {
            await startCameraWithFacing(cameraFacing);
        } catch (err) {
            console.error("Error restarting camera after toggle:", err);
            showCameraError("Failed to switch camera. Please try remeasuring.");
            stopMeasuring(); 
            initialState.classList.remove('hidden'); 
            measuringState.classList.add('hidden');
            resultsState.classList.add('hidden');
        }
      }
    }

    function updateFlashButtonUI() {
        if (flashSupported && measuring) { 
            flashToggleBtn.classList.remove('hidden');
            flashToggleText.textContent = flashActive ? 'Turn Flash Off' : 'Turn Flash On';
        } else {
            flashToggleBtn.classList.add('hidden');
        }
    }

    async function toggleFlash() {
        if (!stream || !flashSupported || !measuring) return;
        const track = stream.getVideoTracks()[0];
        if (!track) return;

        try {
            flashActive = !flashActive; 
            await track.applyConstraints({ advanced: [{ torch: flashActive }] });
            console.log(`Flash ${flashActive ? 'activated' : 'deactivated'}`);
        } catch (e) {
            console.error("Error applying torch constraint:", e);
            flashActive = !flashActive; 
            showCameraError("Failed to toggle flash. Your camera might not support it or is in use.");
        }
        updateFlashButtonUI();
    }

    async function turnOffFlashIfNeeded() {
        if (stream && flashActive && flashSupported) {
            const track = stream.getVideoTracks()[0];
            if (track) {
                try {
                    await track.applyConstraints({ advanced: [{ torch: false }] });
                    flashActive = false;
                    console.log("Flash turned off during cleanup.");
                } catch (e) {
                    console.error("Could not turn off flash during cleanup:", e);
                }
            }
        }
    }
    
    async function startCameraWithFacing(facing) {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showCameraError("Your browser doesn't support camera access (getUserMedia).");
        return false;
      }
      try {
        cameraError.classList.add('hidden'); 
        const constraints = { video: { facingMode: facing, width: { ideal: 640 }, height: { ideal: 480 }, frameRate: { ideal: FPS } } };
        const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
        stream = mediaStream; 
        
        processingVideo.srcObject = mediaStream; await processingVideo.play();
        previewVideo.srcObject = mediaStream; await previewVideo.play();

        const track = stream.getVideoTracks()[0];
        if (track) {
            const capabilities = track.getCapabilities();
            flashSupported = !!capabilities.torch; 
            if(!flashSupported) flashActive = false;
        } else {
            flashSupported = false; flashActive = false;
        }
        updateFlashButtonUI(); 
        return true; 
      } catch (error) {
        console.error(`Error accessing ${facing} camera:`, error.name, error.message, error);
        let userErrorMessage = `Unable to access ${facing} camera. Please check permissions.`;
        if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') userErrorMessage = `No ${facing} camera found. Try switching cameras or ensure it's connected.`;
        else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') userErrorMessage = `Permission to use the camera was denied. Please allow camera access in your browser settings.`;
        else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') userErrorMessage = `The ${facing} camera does not support the required settings (e.g., resolution).`;
        else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') userErrorMessage = `The camera is currently in use by another application or a hardware error occurred.`;

        if (facing === 'environment' && availableCameras.some(cam => {
            const caps = cam.getCapabilities ? cam.getCapabilities() : {};
            return caps.facingMode && caps.facingMode.includes('user');
        })) {
          console.log('Trying user-facing camera as fallback...');
          cameraFacing = 'user'; updateCameraToggleText();
          try { return await startCameraWithFacing('user'); } 
          catch (err) { showCameraError(userErrorMessage); return false; }
        } else { showCameraError(userErrorMessage); return false; }
      }
    }
    
    function showCameraError(message) {
      cameraError.textContent = message;
      cameraError.classList.remove('hidden');
    }
    
    function processFrame() {
      if (!processingVideo || !processingCanvas || !measuring || !stream || processingVideo.paused || processingVideo.ended) return; 
      
      const video = processingVideo; const canvas = processingCanvas;
      const ctx = canvas.getContext('2d', { willReadFrequently: true }); 
      
      if (canvas.width !== 150 || canvas.height !== 150) { canvas.width = 150; canvas.height = 150; }
      
      if (video.videoWidth > 0 && video.videoHeight > 0) {
        const srcX = (video.videoWidth - canvas.width) / 2; const srcY = (video.videoHeight - canvas.height) / 2;
        ctx.drawImage(video, srcX, srcY, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
        
        const roiX = canvas.width / 2 - 20; const roiY = canvas.height / 2 - 20;
        const roiWidth = 40; const roiHeight = 40;
        const pixelData = ctx.getImageData(roiX, roiY, roiWidth, roiHeight).data;
        
        let totalRed = 0; let pixelCount = 0;
        for (let i = 0; i < pixelData.length; i += 4) { totalRed += pixelData[i]; pixelCount++; }
        const avgRed = pixelCount > 0 ? totalRed / pixelCount : 0;
        
        redValuesBuffer.push(avgRed);
        if (redValuesBuffer.length > BUFFER_SIZE) redValuesBuffer.shift();
        dataPoints = [...redValuesBuffer]; 
        updateVisualization();
      }
      
      if (previewCanvas) {
        const previewCtx = previewCanvas.getContext('2d');
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        previewCtx.strokeStyle = 'red'; previewCtx.lineWidth = 2;
        const previewRoiX = previewCanvas.width / 2 - 20; const previewRoiY = previewCanvas.height / 2 - 20;
        previewCtx.strokeRect(previewRoiX, previewRoiY, 40, 40);
      }
      if (measuring) frameProcessorId = requestAnimationFrame(processFrame); 
    }

    function smoothSignal(data, windowSize) {
        if (data.length < windowSize) return data; 
        const smoothed = [];
        for (let i = 0; i < data.length; i++) {
            const start = Math.max(0, i - Math.floor(windowSize / 2));
            const end = Math.min(data.length, i + Math.ceil(windowSize / 2));
            const windowSlice = data.slice(start, end);
            const sum = windowSlice.reduce((acc, val) => acc + val, 0);
            smoothed.push(sum / windowSlice.length);
        }
        return smoothed;
    }
    
    function calculateHeartRate() {
      if (redValuesBuffer.length < FPS * 3) { 
        console.warn("HR_CALC: Not enough data points in buffer:", redValuesBuffer.length); 
        return null; 
      }

      const smoothedRedValues = smoothSignal([...redValuesBuffer], SMOOTHING_WINDOW_SIZE);
      if (smoothedRedValues.length < FPS * 2) { 
          console.warn("HR_CALC: Not enough smoothed data points:", smoothedRedValues.length);
          return null;
      }

      const mean = smoothedRedValues.reduce((sum, val) => sum + val, 0) / smoothedRedValues.length;
      const normalizedValues = smoothedRedValues.map(val => val - mean);
      
      let initialPeaks = [];
      if (normalizedValues.length === 0) {
          console.warn("HR_CALC: Normalized values array is empty.");
          return null;
      }

      const maxNormalizedValue = Math.max(...normalizedValues);
      // Adjusted threshold: higher relative component, slightly higher absolute minimum.
      const peakThreshold = maxNormalizedValue > 0.02 ? maxNormalizedValue * 0.30 : 0.015;
      console.log(`HR_CALC: MaxNormVal: ${maxNormalizedValue.toFixed(4)}, PeakThreshold: ${peakThreshold.toFixed(4)}`);
      
      for (let i = 1; i < normalizedValues.length - 1; i++) {
        if (normalizedValues[i] > normalizedValues[i-1] && 
            normalizedValues[i] > normalizedValues[i+1] &&
            normalizedValues[i] > peakThreshold) { 
          initialPeaks.push(i); 
        }
      }
      console.log("HR_CALC: Initial peaks found:", initialPeaks.length, initialPeaks);
      
      if (initialPeaks.length < 2) { 
        console.warn(`HR_CALC: Not enough initial peaks detected (${initialPeaks.length}).`); 
        return null; 
      }

      // Filter peaks by minimum distance - stricter
      let refinedPeaks = [initialPeaks[0]];
      for (let i = 1; i < initialPeaks.length; i++) {
          // Peaks must be at least 80% of the minimum physiological interval apart
          if (initialPeaks[i] - refinedPeaks[refinedPeaks.length - 1] >= MIN_PEAK_INTERVAL_FRAMES * 0.8) { 
              refinedPeaks.push(initialPeaks[i]);
          }
      }
      console.log("HR_CALC: Refined peaks found:", refinedPeaks.length, refinedPeaks);
      
      if (refinedPeaks.length < 2) { 
        console.warn(`HR_CALC: Not enough refined peaks after distance filtering (${refinedPeaks.length}).`); 
        return null; 
      }
      
      let peakIntervals = [];
      for (let i = 1; i < refinedPeaks.length; i++) {
        const interval = refinedPeaks[i] - refinedPeaks[i-1];
        if (interval >= MIN_PEAK_INTERVAL_FRAMES && interval <= MAX_PEAK_INTERVAL_FRAMES) {
            peakIntervals.push(interval);
        } else {
            console.warn(`HR_CALC: Discarding interval ${interval} (Min: ${MIN_PEAK_INTERVAL_FRAMES}, Max: ${MAX_PEAK_INTERVAL_FRAMES})`);
        }
      }
      console.log("HR_CALC: Valid peak intervals:", peakIntervals.length, peakIntervals);

      if (peakIntervals.length < 1) { 
          console.warn("HR_CALC: No valid peak intervals found after filtering.");
          return null;
      }
      
      peakIntervals.sort((a, b) => a - b);
      const medianInterval = peakIntervals[Math.floor(peakIntervals.length / 2)];
      console.log("HR_CALC: Median interval (frames):", medianInterval);

      if (medianInterval === 0 || typeof medianInterval === 'undefined') { 
          console.warn("HR_CALC: Median peak interval is zero or undefined.");
          return null;
      }

      const hr = Math.round((FPS * 60) / medianInterval);
      console.log("HR_CALC: Calculated HR:", hr);
      
      if (hr >= 40 && hr <= 200) return hr; 
      else { 
          console.warn(`HR_CALC: Final HR (${hr} BPM) is outside typical range. MedianInterval: ${medianInterval.toFixed(2)}`); 
          return null; 
      }
    }
    
    async function startMeasurement() {
      if (countdownTimer) clearInterval(countdownTimer);
      if (singleMeasurementTimer) clearTimeout(singleMeasurementTimer);

      measuring = true; countdown = 5; 
      redValuesBuffer = []; dataPoints = []; 
      measurementNumber = 0; individualReadings = [];
      
      initialState.classList.add('hidden'); resultsState.classList.add('hidden');
      measuringState.classList.remove('hidden'); cameraError.classList.add('hidden'); 
      
      countdownElement.textContent = countdown; countdownElement.classList.add('pulse'); 
      clearVisualization(); updateMeasurementIndicators(); clearReadings();
      updateFlashButtonUI(); 
      
      try {
        const cameraStarted = await startCameraWithFacing(cameraFacing);
        if (!cameraStarted) {
          await stopMeasuring(); 
          initialState.classList.remove('hidden'); 
          measuringState.classList.add('hidden'); 
          return; 
        }
        
        countdownTimer = setInterval(() => {
          countdown--; countdownElement.textContent = countdown;
          if (countdown <= 0) {
            clearInterval(countdownTimer); countdownTimer = null; 
            countdownElement.classList.remove('pulse'); 
            measurementNumber = 1; 
            startSingleMeasurement();
          }
        }, 1000);
      } catch (error) { 
        console.error('Error starting measurement process:', error);
        showCameraError('An unexpected error occurred while starting measurement.');
        await stopMeasuring();
        initialState.classList.remove('hidden'); measuringState.classList.add('hidden');
      }
    }
    
    function startSingleMeasurement() {
      if (singleMeasurementTimer) clearTimeout(singleMeasurementTimer);

      countdownElement.textContent = `${measurementNumber}/${TOTAL_MEASUREMENTS}`;
      updateMeasurementIndicators(); redValuesBuffer = [];
      
      if (frameProcessorId) cancelAnimationFrame(frameProcessorId); 
      frameProcessorId = requestAnimationFrame(processFrame);
      
      singleMeasurementTimer = setTimeout(async () => { 
        if (frameProcessorId) { cancelAnimationFrame(frameProcessorId); frameProcessorId = null; }
        
        const hr = calculateHeartRate();
        const newReading = (hr !== null) ? hr : FAILED_MEASUREMENT_TEXT;
        individualReadings.push(newReading);
        updateReadings(); updateMeasurementIndicators(); 
        
        if (measurementNumber < TOTAL_MEASUREMENTS) {
          measurementNumber++; 
           setTimeout(() => startSingleMeasurement(), 1000); 
        } else {
          const validReadings = individualReadings.filter(r => typeof r === 'number' && r >= 40 && r <= 220);
          let finalHR = validReadings.length > 0 ? [...validReadings].sort((a, b) => a - b)[Math.floor(validReadings.length / 2)] : FAILED_MEASUREMENT_TEXT;
          heartRate = finalHR; 
          
          if (typeof heartRate === 'number') {
            recommendedTempo = Math.floor(heartRate * 0.7);
            tempoValue.textContent = `${recommendedTempo} BPM`; currentTempo.textContent = recommendedTempo;
            startSessionBtn.disabled = false; startSessionBtn.classList.remove('btn-disabled'); 
          } else {
            recommendedTempo = FAILED_MEASUREMENT_TEXT; 
            tempoValue.textContent = "N/A"; currentTempo.textContent = "N/A";
            startSessionBtn.disabled = true; startSessionBtn.classList.add('btn-disabled'); 
          }
          heartRateValue.textContent = (typeof heartRate === 'number') ? `${heartRate} BPM` : "Measurement Failed";
          updateResultReadings(); 
          measuringState.classList.add('hidden'); resultsState.classList.remove('hidden');
          await stopMeasuring(); 
        }
      }, MEASUREMENT_DURATION * 1000);
    }
    
    async function stopMeasuring() { 
      measuring = false; 
      await turnOffFlashIfNeeded(); 
      
      if (frameProcessorId) { cancelAnimationFrame(frameProcessorId); frameProcessorId = null; }
      if (stream) { stream.getTracks().forEach(track => track.stop()); stream = null; }

      if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null; }
      if (singleMeasurementTimer) { clearTimeout(singleMeasurementTimer); singleMeasurementTimer = null; }
      if (simulateCountdownTimer) { clearInterval(simulateCountdownTimer); simulateCountdownTimer = null; }
      if (simulateSingleMeasurementTimer) { clearTimeout(simulateSingleMeasurementTimer); simulateSingleMeasurementTimer = null;}
      if (animateSimulatedDataId) { cancelAnimationFrame(animateSimulatedDataId); animateSimulatedDataId = null;}

      flashSupported = false; flashActive = false;
      updateFlashButtonUI(); 
    }
    
    function simulateMeasurement() {
      if (simulateCountdownTimer) clearInterval(simulateCountdownTimer);
      if (simulateSingleMeasurementTimer) clearTimeout(simulateSingleMeasurementTimer);

      measuring = true; countdown = 5; redValuesBuffer = [];
      measurementNumber = 0; individualReadings = [];
      
      initialState.classList.add('hidden'); resultsState.classList.add('hidden');
      measuringState.classList.remove('hidden'); cameraError.classList.add('hidden');
      
      countdownElement.textContent = countdown; countdownElement.classList.add('pulse');
      clearVisualization(); updateMeasurementIndicators(); clearReadings();
      flashToggleBtn.classList.add('hidden'); 
      
      simulateCountdownTimer = setInterval(() => {
        countdown--; countdownElement.textContent = countdown;
        if (countdown <= 0) {
          clearInterval(simulateCountdownTimer); simulateCountdownTimer = null;
          countdownElement.classList.remove('pulse');
          measurementNumber = 1;
          simulateSingleMeasurement(); 
        }
      }, 1000);
    }

    function simulateSingleMeasurement() {
        if (simulateSingleMeasurementTimer) clearTimeout(simulateSingleMeasurementTimer);
        countdownElement.textContent = `${measurementNumber}/${TOTAL_MEASUREMENTS}`;
        updateMeasurementIndicators(); simulateDataPoints(); 

        simulateSingleMeasurementTimer = setTimeout(() => {
            const success = Math.random() > 0.2; 
            const simulatedReading = success ? (Math.floor(Math.random() * 25) + 65) : FAILED_MEASUREMENT_TEXT;
            individualReadings.push(simulatedReading);
            updateReadings(); updateMeasurementIndicators(); 

            if (measurementNumber < TOTAL_MEASUREMENTS) {
                measurementNumber++;
                simulateSingleMeasurement(); 
            } else {
                const validReadings = individualReadings.filter(r => typeof r === 'number');
                let finalHR = validReadings.length > 0 ? [...validReadings].sort((a, b) => a - b)[Math.floor(validReadings.length / 2)] : FAILED_MEASUREMENT_TEXT;
                heartRate = finalHR;

                if (typeof heartRate === 'number') {
                    recommendedTempo = Math.floor(heartRate * 0.7);
                    tempoValue.textContent = `${recommendedTempo} BPM`; currentTempo.textContent = recommendedTempo;
                    startSessionBtn.disabled = false; startSessionBtn.classList.remove('btn-disabled');
                } else {
                    recommendedTempo = "N/A"; tempoValue.textContent = "N/A"; currentTempo.textContent = "N/A";
                    startSessionBtn.disabled = true; startSessionBtn.classList.add('btn-disabled');
                }
                heartRateValue.textContent = (typeof heartRate === 'number') ? `${heartRate} BPM` : "Measurement Failed";
                updateResultReadings();
                measuringState.classList.add('hidden'); resultsState.classList.remove('hidden');
                measuring = false; 
            }
        }, MEASUREMENT_DURATION * 250); 
    }
    
    function simulateDataPoints() {
      if (animateSimulatedDataId) cancelAnimationFrame(animateSimulatedDataId);
      redValuesBuffer = []; 
      const baseValue = 150, amplitude = 30, frequency = 1.2, durationSeconds = 3, numPoints = FPS * durationSeconds;
      for (let i = 0; i < numPoints; i++) {
        const time = i / FPS, pulse = Math.sin(time * Math.PI * 2 * frequency) * amplitude, noise = Math.random() * 10 - 5; 
        redValuesBuffer.push(baseValue + pulse + noise);
      }
      dataPoints = [...redValuesBuffer]; updateVisualization(); 
      
      let animationFrameCount = 0;
      function animateSimulatedData() {
        if (!measuring || redValuesBuffer.length === 0) { animateSimulatedDataId = null; return; }
        redValuesBuffer.shift();
        const time = (numPoints + animationFrameCount) / FPS, pulse = Math.sin(time * Math.PI * 2 * frequency) * amplitude, noise = Math.random() * 10 - 5;
        redValuesBuffer.push(baseValue + pulse + noise);
        dataPoints = [...redValuesBuffer]; updateVisualization(); animationFrameCount++;
        if (measuring) animateSimulatedDataId = requestAnimationFrame(animateSimulatedData); 
        else animateSimulatedDataId = null;
      }
      if (measuring) animateSimulatedDataId = requestAnimationFrame(animateSimulatedData);
    }
    
    function startMeditation() {
      if (typeof heartRate !== 'number' || meditationActive) return; 
      if (animationId) clearInterval(animationId); 

      meditationActive = true; progress = 0;
      startSessionBtn.classList.add('hidden'); endSessionBtn.classList.remove('hidden');
      meditationSection.classList.remove('hidden'); progressFill.style.width = '0%';
      
      const totalMeditationDurationMs = 10 * 60 * 1000, progressUpdateIntervalMs = totalMeditationDurationMs / 100; 
      animationId = setInterval(() => {
        progress += 1; progressFill.style.width = `${progress}%`;
        if (progress >= 100) endMeditation();
      }, progressUpdateIntervalMs); 
    }
    
    function endMeditation() {
      meditationActive = false;
      startSessionBtn.classList.remove('hidden'); endSessionBtn.classList.add('hidden');
      if (animationId) { clearInterval(animationId); animationId = null; }
    }
    
    function updateVisualization() {
      visualization.innerHTML = ''; 
      const displayPoints = dataPoints.slice(-100); 
      if (displayPoints.length === 0) return;
      const minVal = Math.min(...displayPoints), maxVal = Math.max(...displayPoints); 
      const range = (maxVal - minVal) === 0 ? 1 : (maxVal - minVal); 
      for (let i = 0; i < displayPoints.length; i++) {
        const value = displayPoints[i], normalizedValue = ((value - minVal) / range) * 100; 
        const height = Math.max(1, Math.min(100, normalizedValue)); 
        const bar = document.createElement('div'); bar.className = 'visualization-bar';
        bar.style.height = `${height}%`; bar.style.left = `${(i / displayPoints.length) * 100}%`; 
        bar.style.width = `${Math.max(1, 100 / displayPoints.length)}%`; 
        visualization.appendChild(bar);
      }
    }
    
    function clearVisualization() { visualization.innerHTML = ''; dataPoints = []; }
    
    function updateReadings() {
      readings.innerHTML = ''; 
      individualReadings.forEach((reading) => {
        const readingElement = document.createElement('div'); readingElement.className = 'reading';
        if (reading === FAILED_MEASUREMENT_TEXT) readingElement.innerHTML = `<span class="reading-value">${FAILED_MEASUREMENT_TEXT}</span>`;
        else readingElement.innerHTML = `<span class="reading-value">${reading}</span><span class="reading-unit">&nbsp;BPM</span>`;
        readings.appendChild(readingElement);
      });
    }
    
    function clearReadings() { readings.innerHTML = ''; }
    
    function updateResultReadings() {
      resultReadings.innerHTML = ''; 
      individualReadings.forEach((reading) => {
        const readingElement = document.createElement('div'); readingElement.className = 'result-reading';
        let iconSvg = '', readingText = '';
        if (reading === FAILED_MEASUREMENT_TEXT) {
          iconSvg = `<svg class="icon icon-xs" viewBox="0 0 24 24" style="color: #ef4444; margin-right: 4px;"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
          readingText = FAILED_MEASUREMENT_TEXT;
        } else {
          iconSvg = `<svg class="icon icon-xs" viewBox="0 0 24 24" style="color: #10b981; margin-right: 4px;"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
          readingText = `${reading} BPM`;
        }
        readingElement.innerHTML = iconSvg + readingText;
        resultReadings.appendChild(readingElement);
      });
    }
    
    function updateMeasurementIndicators() {
      const indicators = measurementIndicators.querySelectorAll('.indicator');
      for (let i = 0; i < indicators.length; i++) {
        indicators[i].className = 'indicator'; 
        if (i < individualReadings.length) {
            if (individualReadings[i] === FAILED_MEASUREMENT_TEXT) indicators[i].classList.add('failed');
            else indicators[i].classList.add('complete');
        } else if (i === measurementNumber -1 && measuring) { 
            indicators[i].classList.add('active');
        }
      }
    }
    
    document.addEventListener('DOMContentLoaded', function() {
      checkCameras(); 
      startMeasurementBtn.addEventListener('click', startMeasurement);
      cameraToggle.addEventListener('click', toggleCamera);
      flashToggleBtn.addEventListener('click', toggleFlash); 
      remeasureBtn.addEventListener('click', startMeasurement); 
      startSessionBtn.addEventListener('click', startMeditation);
      endSessionBtn.addEventListener('click', endMeditation);
    });
    
    window.addEventListener('beforeunload', async function() { 
      await stopMeasuring(); 
    });
  </script>
</body>
</html>
