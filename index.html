<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rhythm Breath - Heart Rate Based Meditation</title>
  <style>
    /* Base styles */
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f3f4f6;
      color: #374151;
    }
    
    .container {
      max-width: 480px;
      margin: 0 auto;
      padding: 24px;
    }
    
    .hidden {
      display: none !important;
    }
    
    /* Header */
    .header {
      text-align: center;
      margin-bottom: 24px;
    }
    
    .app-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: #4f46e5;
      margin-bottom: 8px;
    }
    
    .app-subtitle {
      color: #6b7280;
      font-size: 0.9rem;
      margin-top: 0;
    }
    
    /* Main card */
    .card {
      background-color: white;
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin-bottom: 24px;
      text-align: center;
    }
    
    /* Camera section */
    .camera-icon {
      background-color: #fee2e2;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 16px auto;
    }
    
    .camera-instruction {
      margin-bottom: 16px;
    }
    
    .camera-toggle, .flash-toggle { /* Added .flash-toggle */
      background: none;
      border: none;
      color: #4f46e5;
      font-size: 0.875rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      margin: 8px auto 16px auto; /* Adjusted margin for multiple toggles */
    }
    
    .camera-toggle svg, .flash-toggle svg { /* Added .flash-toggle */
      margin-right: 4px;
    }
    
    .camera-error {
      color: #ef4444;
      font-size: 0.875rem;
      margin-bottom: 16px;
    }
    
    /* Camera preview */
    .preview-container {
      position: relative;
      width: 128px;
      height: 128px;
      margin: 0 auto 16px auto;
    }
    
    .camera-preview {
      width: 128px;
      height: 128px;
      border-radius: 8px;
      border: 2px solid #f87171;
      object-fit: cover;
    }
    
    .preview-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .preview-help {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 4px;
    }
    
    /* Finger guidance elements */
    .target-area {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      border: 2px dashed #f87171;
      border-radius: 8px;
      z-index: 2;
    }
    
    .finger-dot {
      position: absolute;
      width: 12px;
      height: 12px;
      background-color: white;
      border: 2px solid #ef4444;
      border-radius: 50%;
      z-index: 3;
      transform: translate(-50%, -50%);
      transition: all 0.1s ease-out;
    }
    
    .preview-guidance {
      text-align: center;
      font-size: 0.875rem;
      color: #ef4444;
      font-weight: 500;
      margin-top: 8px;
    }
    
    .good-position {
      color: #10b981;
    }
    
    /* Signal quality indicator */
    .signal-quality {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 8px;
      font-size: 0.75rem;
    }
    
    .quality-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 4px;
    }
    
    .quality-poor {
      background-color: #f59e0b;
    }
    
    .quality-fair {
      background-color: #3b82f6;
    }
    
    .quality-good {
      background-color: #10b981;
    }
    
    /* Countdown */
    .countdown {
      width: 64px;
      height: 64px;
      background-color: #ef4444;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 700;
      font-size: 1.25rem;
      margin: 0 auto 8px auto;
    }
    
    .countdown.pulse {
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(0.95);
        box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
      }
      
      70% {
        transform: scale(1);
        box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
      }
      
      100% {
        transform: scale(0.95);
        box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
      }
    }
    
    .keep-steady {
      margin-bottom: 8px;
    }
    
    /* Measurement indicators */
    .measurement-indicators {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 8px;
    }
    
    .indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: #d1d5db; /* Default gray */
    }
    
    .indicator.active {
      background-color: #ef4444; /* Red for active */
      animation: pulse 1.5s infinite;
    }
    
    .indicator.complete {
      background-color: #10b981; /* Green for complete */
    }

    .indicator.failed {
      background-color: #f59e0b; /* Amber/Orange for failed */
    }
    
    /* Readings display */
    .readings {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-top: 12px;
      font-size: 0.75rem;
    }
    
    .reading {
      display: flex;
      align-items: center;
    }
    
    .reading-value {
      font-weight: 500;
    }
    
    .reading-unit {
      color: #6b7280;
    }
    
    /* Signal visualization */
    .visualization {
      height: 64px;
      width: 100%;
      background-color: #f3f4f6;
      position: relative;
      overflow: hidden;
      margin-top: 16px;
    }
    
    .visualization-bar {
      position: absolute;
      bottom: 0;
      width: 4px;
      background-color: #ef4444;
      opacity: 0.7;
    }
    
    .visualization-bar.peak {
      background-color: #10b981; /* Green for peaks */
      opacity: 1;
    }
    
    /* Results */
    .heart-rate {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 8px;
    }
    
    .heart-rate-value {
      font-size: 1.5rem;
      font-weight: 700;
      margin-left: 8px;
    }
    
    .result-readings {
      display: flex;
      justify-content: center;
      flex-wrap: wrap; /* Allow readings to wrap if many */
      margin-bottom: 16px;
      font-size: 0.875rem;
    }
    
    .result-reading {
      margin: 0 8px;
      display: flex;
      align-items: center;
    }
    
    .tempo-box {
      background-color: #eef2ff;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 16px;
    }
    
    .tempo-value {
      font-weight: 700;
    }
    
    .tempo-note {
      font-size: 0.875rem;
      color: #6b7280;
      margin-top: 4px;
    }
    
    /* Buttons */
    .btn {
      padding: 8px 24px;
      border-radius: 8px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s ease;
      border: none;
      display: inline-flex;
      align-items: center;
      margin-top: 8px; /* Added some top margin for spacing */
    }
    
    .btn-primary {
      background-color: #4f46e5;
      color: white;
    }
    
    .btn-primary:hover {
      background-color: #4338ca;
    }
    
    .btn-success {
      background-color: #10b981;
      color: white;
    }
    
    .btn-success:hover {
      background-color: #059669;
    }
     .btn-success.btn-disabled {
      background-color: #a0aec0; /* Example disabled color */
      cursor: not-allowed;
      opacity: 0.7;
    }
    
    .btn-danger {
      background-color: #ef4444;
      color: white;
    }
    
    .btn-danger:hover {
      background-color: #dc2626;
    }
    
    .btn-link {
      background: none;
      color: #4f46e5;
      padding: 0;
    }
    
    .btn-link:hover {
      color: #4338ca;
    }
    
    .btn svg {
      margin-right: 4px;
    }
    
    /* Meditation progress */
    .meditation-section {
      margin-bottom: 24px;
    }
    
    .progress-bar {
      height: 12px;
      background-color: #e5e7eb;
      border-radius: 999px;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background-color: #10b981;
      transition: width 0.3s ease-out;
    }
    
    .progress-times {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 4px;
    }
    
    .current-track {
      font-size: 0.875rem;
      color: #6b7280;
      margin-top: 8px;
    }
    
    .track-name {
      font-weight: 500;
    }
    
    /* Info box */
    .info-box {
      background-color: #eef2ff;
      padding: 16px;
      border-radius: 8px;
    }
    
    .info-title {
      font-weight: 600;
      color: #1e40af;
      margin-top: 0;
      margin-bottom: 8px;
    }
    
    .info-text {
      font-size: 0.875rem;
      color: #4b5563;
      margin: 0;
    }

    /* Icons */
    .icon {
      display: inline-block;
      width: 24px;
      height: 24px;
      stroke-width: 2;
      stroke: currentColor;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    
    .icon-sm {
      width: 16px;
      height: 16px;
    }
    
    .icon-xs {
      width: 12px;
      height: 12px;
    }
    
    .icon-lg {
      width: 48px;
      height: 48px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1 class="app-title">Rhythm Breath</h1>
      <p class="app-subtitle">Personalized meditation based on your heart rhythm</p>
    </div>
    
    <div class="hidden">
      <video id="processingVideo" playsinline muted></video>
      <canvas id="processingCanvas"></canvas>
    </div>
    
    <div class="card" id="mainCard">
      <div id="initialState">
        <div class="camera-icon">
          <svg class="icon icon-lg" viewBox="0 0 24 24">
            <rect x="2" y="6" width="20" height="12" rx="2" ry="2"></rect>
            <circle cx="12" cy="12" r="3"></circle>
          </svg>
        </div>
        <p class="camera-instruction">Place your thumb over your camera lens to measure your heart rate</p>
        
        <button id="cameraToggle" class="camera-toggle hidden">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <path d="M23 4v6h-6"></path>
            <path d="M1 20v-6h6"></path>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
            <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
          </svg>
          Switch to front camera
        </button>
        
        <div id="cameraError" class="camera-error hidden"></div>
        
        <button id="startMeasurementBtn" class="btn btn-primary">Start Measurement</button>
      </div>
      
      <div id="measuringState" class="hidden">
        <div class="preview-container" id="previewContainer">
          <video id="previewVideo" class="camera-preview" playsinline muted autoplay></video>
          <canvas id="previewCanvas" class="preview-overlay" width="128" height="128"></canvas>
          <!-- Finger guidance elements will be added by JavaScript -->
        </div>

        <button id="flashToggleBtn" class="flash-toggle btn btn-link hidden">
            <svg class="icon icon-sm" viewBox="0 0 24 24" id="flashIcon">
                <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
            </svg>
            <span id="flashToggleText">Turn Flash On</span>
        </button>
        
        <div id="signalQuality" class="signal-quality hidden">
          <span class="quality-indicator quality-fair"></span>
          <span>Signal Quality: <span id="qualityValue">Calibrating...</span></span>
        </div>
        
        <div id="countdown" class="countdown pulse">5</div>
        <p class="keep-steady">Keep your thumb steady...</p>
        
        <div class="measurement-indicators" id="measurementIndicators">
          <div class="indicator"></div>
          <div class="indicator"></div>
          <div class="indicator"></div>
        </div>
        
        <div id="readings" class="readings"></div>
        
        <div id="visualization" class="visualization"></div>
      </div>
      
      <div id="resultsState" class="hidden">
        <div class="heart-rate">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M22 12h-4l-3 9L9 3l-3 9H2"></path>
          </svg>
          <span id="heartRateValue" class="heart-rate-value">72 BPM</span>
        </div>
        
        <div id="resultReadings" class="result-readings"></div>
        
        <div class="tempo-box">
          <p>Recommended music tempo: <span id="tempoValue" class="tempo-value">60 BPM</span></p>
          <p class="tempo-note">Music at this tempo will help guide your heart rate toward a more relaxed state</p>
        </div>
        
        <button id="remeasureBtn" class="btn btn-link">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <path d="M23 4v6h-6"></path>
            <path d="M1 20v-6h6"></path>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
            <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
          </svg>
          Re-measure
        </button>
        
        <button id="startSessionBtn" class="btn btn-success">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
          </svg>
          Start Session
        </button>
        
        <button id="endSessionBtn" class="btn btn-danger hidden">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <rect x="6" y="4" width="4" height="16"></rect>
            <rect x="14" y="4" width="4" height="16"></rect>
          </svg>
          End Session
        </button>
      </div>
    </div>
    
    <div id="meditationSection" class="meditation-section hidden">
      <div class="progress-bar">
        <div id="progressFill" class="progress-fill" style="width: 0%"></div>
      </div>
      <div class="progress-times">
        <span>0:00</span>
        <span>10:00</span>
      </div>
      <p class="current-track">
        Currently playing: <span class="track-name">Ocean Calm</span> (<span id="currentTempo">60</span> BPM)
      </p>
    </div>
    
    <div class="info-box">
      <h3 class="info-title">How it works</h3>
      <p class="info-text">
        We use your device's camera and flash to capture subtle color changes in your fingertip
        that correspond to your pulse. We take 3 measurements to ensure accuracy,
        extract the red channel data, filter the signal, analyze the waveform to detect peaks,
        and calculate your heart rate. The flash provides optimal illumination for more
        accurate readings. Then we generate meditation music with a 
        tempo designed to guide you toward a more peaceful state.
      </p>
    </div>
  </div>

  <script>
    // Configuration
    const FPS = 30;
    const MEASUREMENT_DURATION = 8; // seconds
    const BUFFER_SIZE = FPS * MEASUREMENT_DURATION;
    const TOTAL_MEASUREMENTS = 3;
    const FAILED_MEASUREMENT_TEXT = "Failed"; 
    const SMOOTHING_WINDOW_SIZE = 5; // Reduced from 7 for better peak preservation
    const MIN_BPM = 45; // Physiological minimum heart rate
    const MAX_BPM = 190; // Physiological maximum heart rate
    const MIN_PEAK_INTERVAL_FRAMES = Math.round(FPS * (60 / MAX_BPM)); // Min interval for max BPM
    const MAX_PEAK_INTERVAL_FRAMES = Math.round(FPS * (60 / MIN_BPM)); // Max interval for min BPM
    const PEAK_THRESHOLD_PERCENT = 0.25; // Threshold for peak detection

    // State variables
    let measuring = false;
    let heartRate = null;
    let recommendedTempo = null;
    let countdown = 5;
    let meditationActive = false;
    let progress = 0;
    let dataPoints = [];
    let stream = null;
    let measurementNumber = 0;
    let individualReadings = []; 
    let cameraFacing = 'environment'; 
    let availableCameras = [];
    let flashSupported = false;
    let flashActive = false;
    let signalQuality = 'Unknown';
    let lastPeaks = []; // Track peaks for visualization
    
    // Timer management - consolidated
    const timers = {
      countdown: null,
      measurement: null,
      calibration: null,
      animation: null,
      frameProcessor: null
    };
    
    // References to DOM elements
    const initialState = document.getElementById('initialState');
    const measuringState = document.getElementById('measuringState');
    const resultsState = document.getElementById('resultsState');
    const meditationSection = document.getElementById('meditationSection');
    
    const processingVideo = document.getElementById('processingVideo');
    const processingCanvas = document.getElementById('processingCanvas');
    const previewVideo = document.getElementById('previewVideo');
    const previewCanvas = document.getElementById('previewCanvas');
    
    const startMeasurementBtn = document.getElementById('startMeasurementBtn');
    const cameraToggle = document.getElementById('cameraToggle');
    const cameraError = document.getElementById('cameraError');
    const countdownElement = document.getElementById('countdown');
    const measurementIndicators = document.getElementById('measurementIndicators');
    const readings = document.getElementById('readings');
    const visualization = document.getElementById('visualization');
    const signalQualityElement = document.getElementById('signalQuality');
    const qualityValueElement = document.getElementById('qualityValue');
    
    const heartRateValue = document.getElementById('heartRateValue');
    const resultReadings = document.getElementById('resultReadings');
    const tempoValue = document.getElementById('tempoValue');
    const remeasureBtn = document.getElementById('remeasureBtn');
    const startSessionBtn = document.getElementById('startSessionBtn');
    const endSessionBtn = document.getElementById('endSessionBtn');
    
    const progressFill = document.getElementById('progressFill');
    const currentTempo = document.getElementById('currentTempo');

    const flashToggleBtn = document.getElementById('flashToggleBtn'); 
    const flashToggleText = document.getElementById('flashToggleText');
    const flashIcon = document.getElementById('flashIcon'); 
    
    // Variables for processing
    let redValuesBuffer = [];
    let fingerDot = null; // Element for finger positioning guidance
    let targetArea = null; // Element for target area
    let previewGuidance = null; // Element for guidance text
    
    // Helper function to clear all timers
    function clearAllTimers() {
      if (timers.frameProcessor) {
        cancelAnimationFrame(timers.frameProcessor);
        timers.frameProcessor = null;
      }
      
      Object.keys(timers).forEach(key => {
        if (timers[key] && key !== 'frameProcessor') {
          clearTimeout(timers[key]);
          clearInterval(timers[key]);
          timers[key] = null;
        }
      });
    }

    // Check available cameras on page load
    async function checkCameras() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
        console.error("MediaDevices API or enumerateDevices not supported.");
        showCameraError("Camera features are not supported by your browser or device.");
        availableCameras = []; 
        cameraToggle.classList.add('hidden'); 
        updateCameraToggleText(); 
        return;
      }

      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        availableCameras = devices.filter(device => device.kind === 'videoinput');
        
        if (availableCameras.length > 1) {
          cameraToggle.classList.remove('hidden');
        } else {
          cameraToggle.classList.add('hidden');
        }
        
        if (availableCameras.length === 1) {
            const caps = availableCameras[0].getCapabilities ? availableCameras[0].getCapabilities() : null;
            if (caps && caps.facingMode && Array.isArray(caps.facingMode)) {
                if (caps.facingMode.includes('user')) {
                    cameraFacing = 'user';
                } else if (caps.facingMode.length > 0) {
                    cameraFacing = caps.facingMode[0]; 
                } else {
                    cameraFacing = 'environment'; 
                }
            } else {
                 cameraFacing = 'environment'; 
            }
        } else if (availableCameras.length === 0) {
            console.log("No video input devices found.");
        }
        updateCameraToggleText();
      } catch (error) {
        console.error('Error enumerating devices:', error); 
        let userMessage = 'Could not list cameras. Please check browser permissions and ensure your camera is not in use by another app.';
        if (error) {
            if (error.name && error.message) userMessage = `Error listing cameras: ${error.name} (${error.message}).`;
            else if (error.name) userMessage = `Error listing cameras: ${error.name}.`;
            else if (typeof error === 'string' && error.length > 0) userMessage = `Error listing cameras: ${error}.`;
        }
        showCameraError(userMessage);
        availableCameras = []; 
        cameraToggle.classList.add('hidden'); 
        updateCameraToggleText(); 
      }
    }
    
    function updateCameraToggleText() {
      cameraToggle.innerHTML = `
        <svg class="icon icon-sm" viewBox="0 0 24 24">
          <path d="M23 4v6h-6"></path>
          <path d="M1 20v-6h6"></path>
          <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
          <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
        </svg>
        Switch to ${cameraFacing === 'environment' ? 'front' : 'back'} camera
      `;
    }
    
    async function toggleCamera() {
      await updateFlash(false); // Turn off flash when switching cameras
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null; 
      }
      
      cameraFacing = cameraFacing === 'environment' ? 'user' : 'environment';
      updateCameraToggleText();
      flashSupported = false; 
      flashActive = false;
      updateFlashButtonUI(); 
      
      if (measuring) { 
        try {
            await startCameraWithFacing(cameraFacing);
        } catch (err) {
            console.error("Error restarting camera after toggle:", err);
            handleMeasurementError('camera_error', err);
            stopMeasuring(); 
            initialState.classList.remove('hidden'); 
            measuringState.classList.add('hidden');
            resultsState.classList.add('hidden');
        }
      }
    }

    function updateFlashButtonUI() {
        if (flashSupported && measuring) { 
            flashToggleBtn.classList.remove('hidden');
            flashToggleText.textContent = flashActive ? 'Turn Flash Off' : 'Turn Flash On';
        } else {
            flashToggleBtn.classList.add('hidden');
        }
    }

    // Streamlined flash management
    async function updateFlash(enable) {
      if (!stream || !flashSupported) return false;
      const track = stream.getVideoTracks()[0];
      if (!track) return false;
      
      try {
        await track.applyConstraints({ advanced: [{ torch: enable }] });
        flashActive = enable;
        updateFlashButtonUI();
        return true;
      } catch (e) {
        console.error("Flash control error:", e);
        return false;
      }
    }

    async function toggleFlash() {
        await updateFlash(!flashActive);
    }
    
    async function startCameraWithFacing(facing) {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showCameraError("Your browser doesn't support camera access.");
        return false;
      }
      try {
        cameraError.classList.add('hidden'); 
        const constraints = { 
          video: { 
            facingMode: facing, 
            width: { ideal: 640 }, 
            height: { ideal: 480 }, 
            frameRate: { ideal: FPS } 
          }
        };
        const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
        stream = mediaStream; 
        
        processingVideo.srcObject = mediaStream; await processingVideo.play();
        previewVideo.srcObject = mediaStream; await previewVideo.play();

        const track = stream.getVideoTracks()[0];
        if (track) {
            const capabilities = track.getCapabilities();
            flashSupported = !!capabilities.torch; 
            if (flashSupported && measuring) {
              // Auto-enable flash for better PPG quality
              await updateFlash(true);
            } else {
              flashActive = false;
            }
        } else {
            flashSupported = false; flashActive = false;
        }
        updateFlashButtonUI(); 
        return true; 
      } catch (error) {
        console.error(`Error accessing ${facing} camera:`, error);
        let userErrorMessage = `Unable to access the camera. Please check permissions.`;
        
        if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
          userErrorMessage = `No camera found. Please ensure your camera is connected.`;
        } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
          userErrorMessage = `Permission to use the camera was denied. Please allow camera access.`;
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
          userErrorMessage = `The camera is currently in use by another application.`;
        }

        if (facing === 'environment' && availableCameras.some(cam => {
            const caps = cam.getCapabilities ? cam.getCapabilities() : {};
            return caps.facingMode && caps.facingMode.includes('user');
        })) {
          console.log('Trying user-facing camera as fallback...');
          cameraFacing = 'user'; updateCameraToggleText();
          try { return await startCameraWithFacing('user'); } 
          catch (err) { showCameraError(userErrorMessage); return false; }
        } else { showCameraError(userErrorMessage); return false; }
      }
    }
    
    function showCameraError(message) {
      cameraError.textContent = message;
      cameraError.classList.remove('hidden');
    }
    
    // Create and add finger guidance elements
    function setupFingerGuidance() {
      const previewContainer = document.getElementById('previewContainer');
      
      // Create target area element if it doesn't exist
      if (!targetArea) {
        targetArea = document.createElement('div');
        targetArea.className = 'target-area';
        previewContainer.appendChild(targetArea);
      }
      
      // Create finger dot element if it doesn't exist
      if (!fingerDot) {
        fingerDot = document.createElement('div');
        fingerDot.className = 'finger-dot';
        fingerDot.style.left = '50%';
        fingerDot.style.top = '50%';
        previewContainer.appendChild(fingerDot);
      }
      
      // Create guidance text if it doesn't exist
      if (!previewGuidance) {
        previewGuidance = document.createElement('p');
        previewGuidance.className = 'preview-guidance';
        previewGuidance.textContent = "Position your finger on the target";
        // Insert after preview container
        previewContainer.parentNode.insertBefore(previewGuidance, previewContainer.nextSibling);
      }
    }
    
    // Improved frame processing
    function processFrame() {
      if (!processingVideo || !processingCanvas || !measuring || !stream || processingVideo.paused || processingVideo.ended) return; 
      
      const video = processingVideo; const canvas = processingCanvas;
      const ctx = canvas.getContext('2d', { willReadFrequently: true }); 
      
      if (canvas.width !== 150 || canvas.height !== 150) { canvas.width = 150; canvas.height = 150; }
      
      if (video.videoWidth > 0 && video.videoHeight > 0) {
        const srcX = (video.videoWidth - canvas.width) / 2; const srcY = (video.videoHeight - canvas.height) / 2;
        ctx.drawImage(video, srcX, srcY, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
        
        // Track the brightest area (likely the finger)
        const fullPixelData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        let brightestX = 0;
        let brightestY = 0;
        let maxBrightness = 0;
        
        // Scan every 5 pixels to improve performance
        for (let y = 0; y < canvas.height; y += 5) {
          for (let x = 0; x < canvas.width; x += 5) {
            const i = (y * canvas.width + x) * 4;
            const r = fullPixelData[i];
            const g = fullPixelData[i + 1];
            const b = fullPixelData[i + 2];
            
            // Calculate brightness (red channel is most important for PPG)
            const brightness = r * 0.7 + g * 0.2 + b * 0.1;
            
            if (brightness > maxBrightness) {
              maxBrightness = brightness;
              brightestX = x;
              brightestY = y;
            }
          }
        }
        
        // Update the finger dot position
        if (fingerDot && maxBrightness > 100) { // Only track if bright enough
          const previewWidth = previewCanvas.width;
          const previewHeight = previewCanvas.height;
          
          // Scale coordinates from processing canvas to preview canvas
          const scaledX = (brightestX / canvas.width) * previewWidth;
          const scaledY = (brightestY / canvas.height) * previewHeight;
          
          fingerDot.style.left = `${scaledX}px`;
          fingerDot.style.top = `${scaledY}px`;
          
          // Check if finger is in the target area
          const targetCenterX = previewCanvas.width / 2;
          const targetCenterY = previewCanvas.height / 2;
          const distance = Math.sqrt(
            Math.pow(scaledX - targetCenterX, 2) + 
            Math.pow(scaledY - targetCenterY, 2)
          );
          
          // Update guidance message
          if (previewGuidance) {
            if (distance < 25) { // Good position (within 25px of center)
              previewGuidance.textContent = "Perfect! Keep steady";
              previewGuidance.classList.add('good-position');
            } else {
              previewGuidance.textContent = "Move your finger to the target";
              previewGuidance.classList.remove('good-position');
            }
          }
        }
        
        // Extract red channel data from ROI
        const roiX = canvas.width / 2 - 20;
        const roiY = canvas.height / 2 - 20;
        const roiWidth = 40;
        const roiHeight = 40;

        const pixelData = ctx.getImageData(roiX, roiY, roiWidth, roiHeight).data;
        
        let totalRed = 0;
        let pixelCount = 0;
        for (let i = 0; i < pixelData.length; i += 4) {
          totalRed += pixelData[i]; 
          pixelCount++;
        }
        const avgRed = pixelCount > 0 ? totalRed / pixelCount : 0;
        
        redValuesBuffer.push(avgRed);
        
        if (redValuesBuffer.length > BUFFER_SIZE) {
          redValuesBuffer.shift();
        }
        
        dataPoints = [...redValuesBuffer];
        
        // Check signal quality and automate flash if needed
        if (redValuesBuffer.length > FPS * 2) {
          assessSignalQuality();
        }
        
        updateVisualization();
      }
      
      if (previewCanvas) {
        const previewCtx = previewCanvas.getContext('2d');
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        
        // No need to draw ROI box since we have the target area element now
        // But we'll keep this for compatibility
        previewCtx.strokeStyle = 'rgba(255, 99, 71, 0.3)';
        previewCtx.lineWidth = 2;
        const previewRoiX = previewCanvas.width / 2 - 20; 
        const previewRoiY = previewCanvas.height / 2 - 20;
        previewCtx.strokeRect(previewRoiX, previewRoiY, 40, 40);
      }
      
      timers.frameProcessor = requestAnimationFrame(processFrame);
    }
    
    // Signal quality assessment
    function assessSignalQuality() {
      if (redValuesBuffer.length < FPS * 2) return;
      
      const mean = redValuesBuffer.reduce((sum, val) => sum + val, 0) / redValuesBuffer.length;
      const variance = redValuesBuffer.reduce((sum, val) => sum + (val - mean) * (val - mean), 0) / redValuesBuffer.length;
      
      const oldQuality = signalQuality;
      
      if (variance > 25) {
        signalQuality = 'Good';
      } else if (variance > 10) {
        signalQuality = 'Fair';
      } else {
        signalQuality = 'Poor';
        
        // Auto-enable flash for poor signal if not already on
        if (flashSupported && !flashActive) {
          updateFlash(true);
        }
      }
      
      if (oldQuality !== signalQuality) {
        updateSignalQualityUI();
      }
    }
    
    // Update signal quality UI indicator
    function updateSignalQualityUI() {
      if (!signalQualityElement || !qualityValueElement) return;
      
      // Show signal quality element
      signalQualityElement.classList.remove('hidden');
      
      // Update text
      qualityValueElement.textContent = signalQuality;
      
      // Update indicator color
      const qualityIndicator = signalQualityElement.querySelector('.quality-indicator');
      if (qualityIndicator) {
        qualityIndicator.className = 'quality-indicator';
        if (signalQuality === 'Good') {
          qualityIndicator.classList.add('quality-good');
        } else if (signalQuality === 'Fair') {
          qualityIndicator.classList.add('quality-fair');
        } else {
          qualityIndicator.classList.add('quality-poor');
        }
      }
    }
    
    // Helper function: Apply smooth window filter
    function smoothSignal(data, windowSize) {
      if (data.length < windowSize) return data;
      
      const smoothed = [];
      for (let i = 0; i < data.length; i++) {
        const start = Math.max(0, i - Math.floor(windowSize / 2));
        const end = Math.min(data.length, i + Math.ceil(windowSize / 2));
        const windowSlice = data.slice(start, end);
        const sum = windowSlice.reduce((acc, val) => acc + val, 0);
        smoothed.push(sum / windowSlice.length);
      }
      return smoothed;
    }
    
    // Helper function: Find peaks in a signal
    function findPeaks(data, threshold, minDistance) {
      const peaks = [];
      
      for (let i = 2; i < data.length - 2; i++) {
        // Check if this point is higher than adjacent points
        if (data[i] > data[i-1] && 
            data[i] > data[i-2] && 
            data[i] > data[i+1] && 
            data[i] > data[i+2] && 
            data[i] > threshold) {
          
          // If no previous peaks or far enough from last peak
          if (peaks.length === 0 || i - peaks[peaks.length - 1] >= minDistance * 0.7) {
            peaks.push(i);
          }
        }
      }
      
      return peaks;
    }
    
    // Helper function: Get only valid intervals between peaks
    function getValidIntervals(peaks, minInterval, maxInterval) {
      const intervals = [];
      
      for (let i = 1; i < peaks.length; i++) {
        const interval = peaks[i] - peaks[i-1];
        if (interval >= minInterval && interval <= maxInterval) {
          intervals.push(interval);
        }
      }
      
      return intervals;
    }
    
    // Helper function: Get median value of an array
    function getMedian(values) {
      if (values.length === 0) return null;
      
      const sorted = [...values].sort((a, b) => a - b);
      const middle = Math.floor(sorted.length / 2);
      
      return sorted.length % 2 === 0
        ? (sorted[middle - 1] + sorted[middle]) / 2
        : sorted[middle];
    }
    
    // Simplified heart rate calculation
    function calculateHeartRate() {
      if (redValuesBuffer.length < FPS * 3) {
        console.log("Not enough data points in buffer:", redValuesBuffer.length);
        return null;
      }
      
      // Step 1: Smooth and normalize signal
      const smoothed = smoothSignal([...redValuesBuffer], SMOOTHING_WINDOW_SIZE);
      const mean = smoothed.reduce((sum, val) => sum + val, 0) / smoothed.length;
      const normalized = smoothed.map(val => val - mean);
      
      // Step 2: Find peaks with an adaptive threshold
      const maxValue = Math.max(...normalized);
      const threshold = maxValue * PEAK_THRESHOLD_PERCENT;
      
      if (threshold <= 0) {
        console.log("Signal too weak for peak detection");
        return null;
      }
      
      const peaks = findPeaks(normalized, threshold, MIN_PEAK_INTERVAL_FRAMES);
      lastPeaks = peaks; // Store peaks for visualization
      
      if (peaks.length < 2) {
        console.log("Not enough peaks detected:", peaks.length);
        return null;
      }
      
      // Step 3: Calculate intervals and filter outliers
      const intervals = getValidIntervals(peaks, MIN_PEAK_INTERVAL_FRAMES, MAX_PEAK_INTERVAL_FRAMES);
      
      if (intervals.length < 1) {
        console.log("No valid intervals between peaks");
        return null;
      }
      
      // Step 4: Get median interval and calculate heart rate
      const medianInterval = getMedian(intervals);
      
      if (!medianInterval) {
        console.log("Failed to calculate median interval");
        return null;
      }
      
      const hr = Math.round((FPS * 60) / medianInterval);
      
      console.log(`Calculated HR: ${hr} BPM (${intervals.length} intervals, median: ${medianInterval})`);
      
      return (hr >= MIN_BPM && hr <= MAX_BPM) ? hr : null;
    }
    
    // Improved error handling
    function handleMeasurementError(errorType, error) {
      let message = "Measurement failed. Please try again.";
      
      switch (errorType) {
        case 'no_peaks':
          message = "Couldn't detect your pulse. Try placing your finger firmly over the camera.";
          break;
        case 'low_quality':
          message = "Signal quality too low. Try using flash or switching to a brighter environment.";
          break;
        case 'camera_error':
          message = `Camera error: ${error?.message || 'unknown issue'}. Try restarting the app.`;
          break;
      }
      
      showCameraError(message);
    }
    
    // Enhanced visualization with peak indicators
    function updateVisualization() {
      visualization.innerHTML = ''; 
      
      const displayPoints = dataPoints.slice(-100); 
      if (displayPoints.length === 0) return;
      
      const minVal = Math.min(...displayPoints); 
      const maxVal = Math.max(...displayPoints); 
      const range = (maxVal - minVal) === 0 ? 1 : (maxVal - minVal);
      
      // Adjust peak indices for visualization slice
      const visiblePeaks = lastPeaks ? lastPeaks.filter(p => p >= redValuesBuffer.length - 100) : [];
      const adjustedPeaks = visiblePeaks.map(p => p - (redValuesBuffer.length - 100));
      
      for (let i = 0; i < displayPoints.length; i++) {
        const value = displayPoints[i];
        const normalizedValue = ((value - minVal) / range) * 100; 
        const height = Math.max(1, Math.min(100, normalizedValue)); 
        
        const bar = document.createElement('div');
        bar.className = 'visualization-bar';
        bar.style.height = `${height}%`;
        bar.style.left = `${(i / displayPoints.length) * 100}%`; 
        bar.style.width = `${Math.max(1, 100 / displayPoints.length)}%`;
        
        // Highlight detected peaks
        if (adjustedPeaks.includes(i)) {
          bar.classList.add('peak');
        }
        
        visualization.appendChild(bar);
      }
    }
    
    // Clear visualization
    function clearVisualization() {
      visualization.innerHTML = '';
      dataPoints = [];
      lastPeaks = [];
    }
    
    // Start measurement process
    async function startMeasurement() {
      clearAllTimers();
      
      measuring = true;
      countdown = 5; 
      redValuesBuffer = [];
      dataPoints = []; 
      measurementNumber = 0; 
      individualReadings = [];
      lastPeaks = [];
      signalQuality = 'Unknown';
      
      initialState.classList.add('hidden');
      resultsState.classList.add('hidden');
      measuringState.classList.remove('hidden');
      cameraError.classList.add('hidden');
      signalQualityElement.classList.add('hidden');
      
      countdownElement.textContent = countdown;
      countdownElement.classList.add('pulse'); 
      clearVisualization();
      updateMeasurementIndicators(); 
      clearReadings();
      
      // Setup finger guidance
      setupFingerGuidance();
      
      try {
        const cameraStarted = await startCameraWithFacing(cameraFacing);
        
        if (!cameraStarted) {
          await stopMeasuring(); 
          initialState.classList.remove('hidden'); 
          measuringState.classList.add('hidden'); 
          return; 
        }
        
        timers.countdown = setInterval(() => {
          countdown--;
          countdownElement.textContent = countdown;
          
          if (countdown <= 0) {
            clearInterval(timers.countdown);
            timers.countdown = null;
            countdownElement.classList.remove('pulse'); 
            measurementNumber = 1; 
            startSingleMeasurement();
          }
        }, 1000);
      } catch (error) { 
        console.error('Error starting measurement process:', error);
        handleMeasurementError('camera_error', error);
        await stopMeasuring();
        initialState.classList.remove('hidden');
        measuringState.classList.add('hidden');
      }
    }
    
    // Start a single measurement
    function startSingleMeasurement() {
      countdownElement.textContent = `${measurementNumber}/${TOTAL_MEASUREMENTS}`;
      updateMeasurementIndicators(); 
      
      redValuesBuffer = [];
      lastPeaks = [];
      
      if (timers.frameProcessor) {
        cancelAnimationFrame(timers.frameProcessor);
      }
      
      timers.frameProcessor = requestAnimationFrame(processFrame);
      
      // Show signal quality after initial stabilization
      timers.calibration = setTimeout(() => {
        assessSignalQuality();
        signalQualityElement.classList.remove('hidden');
      }, 2000);
      
      // Complete the measurement after the full duration
      timers.measurement = setTimeout(() => {
        if (timers.frameProcessor) {
          cancelAnimationFrame(timers.frameProcessor);
          timers.frameProcessor = null;
        }
        
        const hr = calculateHeartRate();
        let errorType = null;
        
        if (hr === null) {
          if (lastPeaks.length < 2) {
            errorType = 'no_peaks';
          } else if (signalQuality === 'Poor') {
            errorType = 'low_quality';
          }
        }
        
        const newReading = (hr !== null) ? hr : FAILED_MEASUREMENT_TEXT;
        individualReadings.push(newReading);
        
        updateReadings(); 
        updateMeasurementIndicators(); 
        
        if (errorType) {
          handleMeasurementError(errorType);
        }
        
        if (measurementNumber < TOTAL_MEASUREMENTS) {
          measurementNumber++; 
          setTimeout(() => {
            startSingleMeasurement();
          }, 1000); 
        } else {
          // Complete all measurements
          finalizeMeasurements();
        }
      }, MEASUREMENT_DURATION * 1000);
    }
    
    // Finalize measurements and show results
    function finalizeMeasurements() {
      const validReadings = individualReadings.filter(r => typeof r === 'number' && r >= MIN_BPM && r <= MAX_BPM);
      
      let finalHR;
      if (validReadings.length > 0) {
        const sortedReadings = [...validReadings].sort((a, b) => a - b);
        finalHR = sortedReadings[Math.floor(sortedReadings.length / 2)];
      } else {
        finalHR = FAILED_MEASUREMENT_TEXT; 
      }
      
      heartRate = finalHR; 
      
      if (typeof heartRate === 'number') {
        recommendedTempo = Math.max(50, Math.floor(heartRate * 0.7));
        tempoValue.textContent = `${recommendedTempo} BPM`;
        currentTempo.textContent = recommendedTempo;
        startSessionBtn.disabled = false; 
        startSessionBtn.classList.remove('btn-disabled'); 
      } else {
        recommendedTempo = FAILED_MEASUREMENT_TEXT; 
        tempoValue.textContent = "N/A";
        currentTempo.textContent = "N/A";
        startSessionBtn.disabled = true; 
        startSessionBtn.classList.add('btn-disabled'); 
      }
      
      heartRateValue.textContent = (typeof heartRate === 'number') ? `${heartRate} BPM` : "Measurement Failed";
      updateResultReadings(); 
      
      measuringState.classList.add('hidden');
      resultsState.classList.remove('hidden');
      
      stopMeasuring(); 
    }
    
    // Stop measuring and clean up
    async function stopMeasuring() {
      measuring = false; 
      
      // Clear all timers
      clearAllTimers();
      
      // Turn off flash
      if (flashSupported && flashActive) {
        await updateFlash(false);
      }
      
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null; 
      }
      
      // Reset the guidance elements
      if (fingerDot) {
        fingerDot.style.left = '50%';
        fingerDot.style.top = '50%';
      }
      
      if (previewGuidance) {
        previewGuidance.textContent = "Position your finger on the target";
        previewGuidance.classList.remove('good-position');
      }
      
      signalQualityElement.classList.add('hidden');
      flashToggleBtn.classList.add('hidden');
    }
    
    // Update readings display during measurement
    function updateReadings() {
      readings.innerHTML = ''; 
      
      individualReadings.forEach((reading) => {
        const readingElement = document.createElement('div');
        readingElement.className = 'reading';
        
        if (reading === FAILED_MEASUREMENT_TEXT) {
          readingElement.innerHTML = `<span class="reading-value">${FAILED_MEASUREMENT_TEXT}</span>`;
        } else {
          readingElement.innerHTML = `
            <span class="reading-value">${reading}</span>
            <span class="reading-unit">&nbsp;BPM</span>
          `;
        }
        readings.appendChild(readingElement);
      });
    }
    
    // Clear readings display
    function clearReadings() {
      readings.innerHTML = '';
    }
    
    // Update result readings display
    function updateResultReadings() {
      resultReadings.innerHTML = ''; 
      
      individualReadings.forEach((reading) => {
        const readingElement = document.createElement('div');
        readingElement.className = 'result-reading';
        
        let iconSvg = '';
        let readingText = '';

        if (reading === FAILED_MEASUREMENT_TEXT) {
          iconSvg = `
            <svg class="icon icon-xs" viewBox="0 0 24 24" style="color: #ef4444; margin-right: 4px;">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          `;
          readingText = FAILED_MEASUREMENT_TEXT;
        } else {
          iconSvg = `
            <svg class="icon icon-xs" viewBox="0 0 24 24" style="color: #10b981; margin-right: 4px;">
              <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
          `;
          readingText = `${reading} BPM`;
        }
        
        readingElement.innerHTML = iconSvg + readingText;
        resultReadings.appendChild(readingElement);
      });
    }
    
    // Update measurement indicators
    function updateMeasurementIndicators() {
      const indicators = measurementIndicators.querySelectorAll('.indicator');
      
      for (let i = 0; i < indicators.length; i++) {
        indicators[i].className = 'indicator'; // Reset classes
        
        // Check if there's a reading for this indicator's measurement
        if (i < individualReadings.length) { // This measurement has been attempted
            if (individualReadings[i] === FAILED_MEASUREMENT_TEXT) {
                indicators[i].classList.add('failed');
            } else {
                indicators[i].classList.add('complete');
            }
        } else if (i === measurementNumber - 1 && measuring) { // Current measurement in progress
            indicators[i].classList.add('active');
        }
      }
    }
    
    // Start meditation session
    function startMeditation() {
      if (typeof heartRate !== 'number' || meditationActive) return; 

      meditationActive = true;
      progress = 0;
      
      startSessionBtn.classList.add('hidden');
      endSessionBtn.classList.remove('hidden');
      meditationSection.classList.remove('hidden');
      progressFill.style.width = '0%';
      
      const totalMeditationDurationMs = 10 * 60 * 1000; 
      const progressUpdateIntervalMs = totalMeditationDurationMs / 100; 

      timers.animation = setInterval(() => {
        progress += 1;
        progressFill.style.width = `${progress}%`;
        
        if (progress >= 100) {
          endMeditation();
        }
      }, progressUpdateIntervalMs); 
    }
    
    // End meditation session
    function endMeditation() {
      meditationActive = false;
      
      startSessionBtn.classList.remove('hidden');
      endSessionBtn.classList.add('hidden');
      
      if (timers.animation) {
        clearInterval(timers.animation);
        timers.animation = null;
      }
    }
    
    // Event listeners
    document.addEventListener('DOMContentLoaded', function() {
      checkCameras(); 
      
      startMeasurementBtn.addEventListener('click', startMeasurement);
      cameraToggle.addEventListener('click', toggleCamera);
      flashToggleBtn.addEventListener('click', toggleFlash);
      remeasureBtn.addEventListener('click', startMeasurement); 
      startSessionBtn.addEventListener('click', startMeditation);
      endSessionBtn.addEventListener('click', endMeditation);
    });
    
    // Clean up on page unload
    window.addEventListener('beforeunload', async function() {
      await stopMeasuring();
    });
  </script>
</body>
</html>
