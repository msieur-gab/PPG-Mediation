<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rhythm Breath - Heart Rate Based Meditation</title>
  <style>
    /* Base styles */
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f3f4f6;
      color: #374151;
    }
    
    .container {
      max-width: 480px;
      margin: 0 auto;
      padding: 24px;
    }
    
    .hidden {
      display: none !important;
    }
    
    /* Header */
    .header {
      text-align: center;
      margin-bottom: 24px;
    }
    
    .app-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: #4f46e5;
      margin-bottom: 8px;
    }
    
    .app-subtitle {
      color: #6b7280;
      font-size: 0.9rem;
      margin-top: 0;
    }
    
    /* Main card */
    .card {
      background-color: white;
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin-bottom: 24px;
      text-align: center;
    }
    
    /* Camera section */
    .camera-icon {
      background-color: #fee2e2;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 16px auto;
    }
    
    .camera-instruction {
      margin-bottom: 16px;
    }
    
    .flash-status {
      display: inline-flex;
      align-items: center;
      margin-top: 8px;
      font-size: 0.75rem;
      color: #6b7280;
    }
    
    .flash-status.active {
      color: #f59e0b;
    }
    
    .flash-status svg {
      margin-right: 4px;
    }
    
    .camera-toggle {
      background: none;
      border: none;
      color: #4f46e5;
      font-size: 0.875rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      margin: 0 auto 16px auto;
    }
    
    .camera-toggle svg {
      margin-right: 4px;
    }
    
    .camera-error {
      color: #ef4444;
      font-size: 0.875rem;
      margin-bottom: 16px;
    }
    
    /* Camera preview */
    .preview-container {
      position: relative;
      width: 128px;
      height: 128px;
      margin: 0 auto 16px auto;
    }
    
    .camera-preview {
      width: 128px;
      height: 128px;
      border-radius: 8px;
      border: 2px solid #f87171;
      object-fit: cover;
    }
    
    .preview-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .preview-help {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 4px;
    }
    
    /* Finger guidance elements */
    .target-area {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      border: 2px dashed #f87171;
      border-radius: 8px;
      z-index: 2;
    }
    
    .finger-dot {
      position: absolute;
      width: 12px;
      height: 12px;
      background-color: white;
      border: 2px solid #ef4444;
      border-radius: 50%;
      z-index: 3;
      transform: translate(-50%, -50%);
      transition: all 0.1s ease-out;
    }
    
    .preview-guidance {
      text-align: center;
      font-size: 0.875rem;
      color: #ef4444;
      font-weight: 500;
      margin-top: 8px;
    }
    
    .good-position {
      color: #10b981;
    }
    
    /* Countdown */
    .countdown {
      width: 64px;
      height: 64px;
      background-color: #ef4444;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 700;
      font-size: 1.25rem;
      margin: 0 auto 8px auto;
    }
    
    .countdown.pulse {
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(0.95);
        box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
      }
      
      70% {
        transform: scale(1);
        box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
      }
      
      100% {
        transform: scale(0.95);
        box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
      }
    }
    
    .keep-steady {
      margin-bottom: 8px;
    }
    
    /* Measurement indicators */
    .measurement-indicators {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 8px;
    }
    
    .indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: #d1d5db; /* Default gray */
    }
    
    .indicator.active {
      background-color: #ef4444; /* Red for active */
      animation: pulse 1.5s infinite;
    }
    
    .indicator.complete {
      background-color: #10b981; /* Green for complete */
    }

    .indicator.failed {
      background-color: #f59e0b; /* Amber/Orange for failed */
    }
    
    /* Readings display */
    .readings {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-top: 12px;
      font-size: 0.75rem;
    }
    
    .reading {
      display: flex;
      align-items: center;
    }
    
    .reading-value {
      font-weight: 500;
    }
    
    .reading-unit {
      color: #6b7280;
    }
    
    /* Signal quality indicator */
    .signal-quality {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 8px;
      font-size: 0.75rem;
    }
    
    .quality-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 4px;
    }
    
    .quality-poor {
      background-color: #f59e0b;
    }
    
    .quality-fair {
      background-color: #3b82f6;
    }
    
    .quality-good {
      background-color: #10b981;
    }
    
    /* Signal visualization */
    .visualization {
      height: 64px;
      width: 100%;
      background-color: #f3f4f6;
      position: relative;
      overflow: hidden;
      margin-top: 16px;
    }
    
    .visualization-bar {
      position: absolute;
      bottom: 0;
      width: 4px;
      background-color: #ef4444;
      opacity: 0.7;
    }
    
    /* Peak indicator in visualization */
    .visualization-bar.peak {
      background-color: #10b981;
      opacity: 1;
    }
    
    /* Results */
    .heart-rate {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 8px;
    }
    
    .heart-rate-value {
      font-size: 1.5rem;
      font-weight: 700;
      margin-left: 8px;
    }
    
    .result-readings {
      display: flex;
      justify-content: center;
      flex-wrap: wrap; /* Allow readings to wrap if many */
      margin-bottom: 16px;
      font-size: 0.875rem;
    }
    
    .result-reading {
      margin: 0 8px;
      display: flex;
      align-items: center;
    }
    
    .tempo-box {
      background-color: #eef2ff;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 16px;
    }
    
    .tempo-value {
      font-weight: 700;
    }
    
    .tempo-note {
      font-size: 0.875rem;
      color: #6b7280;
      margin-top: 4px;
    }
    
    /* Buttons */
    .btn {
      padding: 8px 24px;
      border-radius: 8px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s ease;
      border: none;
      display: inline-flex;
      align-items: center;
    }
    
    .btn-primary {
      background-color: #4f46e5;
      color: white;
    }
    
    .btn-primary:hover {
      background-color: #4338ca;
    }
    
    .btn-success {
      background-color: #10b981;
      color: white;
    }
    
    .btn-success:hover {
      background-color: #059669;
    }
     .btn-success.btn-disabled {
      background-color: #a0aec0; /* Example disabled color */
      cursor: not-allowed;
    }
    
    .btn-danger {
      background-color: #ef4444;
      color: white;
    }
    
    .btn-danger:hover {
      background-color: #dc2626;
    }
    
    .btn-link {
      background: none;
      color: #4f46e5;
      padding: 0;
    }
    
    .btn-link:hover {
      color: #4338ca;
    }
    
    .btn svg {
      margin-right: 4px;
    }
    
    /* Meditation progress */
    .meditation-section {
      margin-bottom: 24px;
    }
    
    .progress-bar {
      height: 12px;
      background-color: #e5e7eb;
      border-radius: 999px;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background-color: #10b981;
      transition: width 0.3s ease-out;
    }
    
    .progress-times {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 4px;
    }
    
    .current-track {
      font-size: 0.875rem;
      color: #6b7280;
      margin-top: 8px;
    }
    
    .track-name {
      font-weight: 500;
    }
    
    /* Info box */
    .info-box {
      background-color: #eef2ff;
      padding: 16px;
      border-radius: 8px;
    }
    
    .info-title {
      font-weight: 600;
      color: #1e40af;
      margin-top: 0;
      margin-bottom: 8px;
    }
    
    .info-text {
      font-size: 0.875rem;
      color: #4b5563;
      margin: 0;
    }

    /* Icons */
    .icon {
      display: inline-block;
      width: 24px;
      height: 24px;
      stroke-width: 2;
      stroke: currentColor;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    
    .icon-sm {
      width: 16px;
      height: 16px;
    }
    
    .icon-xs {
      width: 12px;
      height: 12px;
    }
    
    .icon-lg {
      width: 48px;
      height: 48px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1 class="app-title">Rhythm Breath</h1>
      <p class="app-subtitle">Personalized meditation based on your heart rhythm</p>
    </div>
    
    <div class="hidden">
      <video id="processingVideo" playsinline muted></video>
      <canvas id="processingCanvas"></canvas>
    </div>
    
    <div class="card" id="mainCard">
      <div id="initialState">
        <div class="camera-icon">
          <svg class="icon icon-lg" viewBox="0 0 24 24">
            <rect x="2" y="6" width="20" height="12" rx="2" ry="2"></rect>
            <circle cx="12" cy="12" r="3"></circle>
          </svg>
        </div>
        <p class="camera-instruction">Place your thumb over your camera lens to measure your heart rate</p>
        
        <button id="cameraToggle" class="camera-toggle hidden">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <path d="M23 4v6h-6"></path>
            <path d="M1 20v-6h6"></path>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
            <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
          </svg>
          Switch to front camera
        </button>
        
        <div id="cameraError" class="camera-error hidden"></div>
        
        <button id="startMeasurementBtn" class="btn btn-primary">Start Measurement</button>
      </div>
      
      <div id="measuringState" class="hidden">
        <div class="preview-container" id="previewContainer">
          <video id="previewVideo" class="camera-preview" playsinline muted autoplay></video>
          <canvas id="previewCanvas" class="preview-overlay" width="128" height="128"></canvas>
          <!-- Finger guidance elements will be added by JavaScript -->
        </div>
        
        <div id="countdown" class="countdown pulse">5</div>
        <p class="keep-steady">Keep your thumb steady...</p>
        
        <div class="measurement-indicators" id="measurementIndicators">
          <div class="indicator"></div>
          <div class="indicator"></div>
          <div class="indicator"></div>
        </div>
        
        <div id="readings" class="readings"></div>
        
        <div id="signalQuality" class="signal-quality hidden">
          <span class="quality-indicator quality-fair"></span>
          <span>Signal Quality: <span id="qualityValue">Calibrating...</span></span>
        </div>
        
        <div id="visualization" class="visualization"></div>
      </div>
      
      <div id="resultsState" class="hidden">
        <div class="heart-rate">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M22 12h-4l-3 9L9 3l-3 9H2"></path>
          </svg>
          <span id="heartRateValue" class="heart-rate-value">72 BPM</span>
        </div>
        
        <div id="resultReadings" class="result-readings"></div>
        
        <div class="tempo-box">
          <p>Recommended music tempo: <span id="tempoValue" class="tempo-value">60 BPM</span></p>
          <p class="tempo-note">Music at this tempo will help guide your heart rate toward a more relaxed state</p>
        </div>
        
        <button id="remeasureBtn" class="btn btn-link">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <path d="M23 4v6h-6"></path>
            <path d="M1 20v-6h6"></path>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
            <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
          </svg>
          Re-measure
        </button>
        
        <button id="startSessionBtn" class="btn btn-success">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
          </svg>
          Start Session
        </button>
        
        <button id="endSessionBtn" class="btn btn-danger hidden">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <rect x="6" y="4" width="4" height="16"></rect>
            <rect x="14" y="4" width="4" height="16"></rect>
          </svg>
          End Session
        </button>
      </div>
    </div>
    
    <div id="meditationSection" class="meditation-section hidden">
      <div class="progress-bar">
        <div id="progressFill" class="progress-fill" style="width: 0%"></div>
      </div>
      <div class="progress-times">
        <span>0:00</span>
        <span>10:00</span>
      </div>
      <p class="current-track">
        Currently playing: <span class="track-name">Ocean Calm</span> (<span id="currentTempo">60</span> BPM)
      </p>
    </div>
    
    <div class="info-box">
      <h3 class="info-title">How it works</h3>
      <p class="info-text">
        We use your device's camera to capture subtle color changes in your fingertip
        that correspond to your pulse. We take 3 measurements to ensure accuracy,
        extract the red channel data, analyze the waveform to detect peaks,
        and calculate your heart rate. Then we generate meditation music with a 
        tempo designed to guide you toward a more peaceful state.
      </p>
    </div>
  </div>

  <script>
    // Configuration
    const FPS = 30;
    const MEASUREMENT_DURATION = 8; // seconds
    const BUFFER_SIZE = FPS * MEASUREMENT_DURATION;
    const CALIBRATION_DURATION = 2; // seconds for auto-calibration
    const TOTAL_MEASUREMENTS = 3;
    const FAILED_MEASUREMENT_TEXT = "Failed"; // Constant for failed measurement
    
    // State variables
    let measuring = false;
    let heartRate = null;
    let recommendedTempo = null;
    let countdown = 5;
    let meditationActive = false;
    let progress = 0;
    let dataPoints = [];
    let stream = null;
    let measurementNumber = 0;
    let individualReadings = []; // Can now store numbers or FAILED_MEASUREMENT_TEXT
    let cameraFacing = 'environment'; // 'environment' for back, 'user' for front
    let availableCameras = [];
    let signalQuality = 'Unknown'; // Signal quality assessment
    let fingerDot = null; // Element for finger positioning guidance
    let targetArea = null; // Element for target area
    let previewGuidance = null; // Element for guidance text
    let hasFlash = false; // Flag for flash/torch availability
    let torchOn = false; // Current torch status
    
    // References to DOM elements
    const initialState = document.getElementById('initialState');
    const measuringState = document.getElementById('measuringState');
    const resultsState = document.getElementById('resultsState');
    const meditationSection = document.getElementById('meditationSection');
    
    const processingVideo = document.getElementById('processingVideo');
    const processingCanvas = document.getElementById('processingCanvas');
    const previewVideo = document.getElementById('previewVideo');
    const previewCanvas = document.getElementById('previewCanvas');
    
    const startMeasurementBtn = document.getElementById('startMeasurementBtn');
    const cameraToggle = document.getElementById('cameraToggle');
    const cameraError = document.getElementById('cameraError');
    const countdownElement = document.getElementById('countdown');
    const measurementIndicators = document.getElementById('measurementIndicators');
    const readings = document.getElementById('readings');
    const visualization = document.getElementById('visualization');
    const signalQualityElement = document.getElementById('signalQuality');
    const qualityValueElement = document.getElementById('qualityValue');
    
    const heartRateValue = document.getElementById('heartRateValue');
    const resultReadings = document.getElementById('resultReadings');
    const tempoValue = document.getElementById('tempoValue');
    const remeasureBtn = document.getElementById('remeasureBtn');
    const startSessionBtn = document.getElementById('startSessionBtn');
    const endSessionBtn = document.getElementById('endSessionBtn');
    
    const progressFill = document.getElementById('progressFill');
    const currentTempo = document.getElementById('currentTempo');
    
    // Variables for processing
    let redValuesBuffer = [];
    let frameProcessorId = null;
    let animationId = null;
    
    // Check available cameras on page load
    async function checkCameras() {
      // First, check if the MediaDevices API and enumerateDevices are supported
      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
        console.error("MediaDevices API or enumerateDevices not supported.");
        showCameraError("Camera features are not supported by your browser or device.");
        availableCameras = []; // Ensure it's empty
        cameraToggle.classList.add('hidden'); // Explicitly hide toggle
        updateCameraToggleText(); // Update UI based on no cameras
        return;
      }

      try {
        // Get list of media devices
        const devices = await navigator.mediaDevices.enumerateDevices();
        availableCameras = devices.filter(device => device.kind === 'videoinput');
        
        // Show or hide camera toggle based on number of cameras
        if (availableCameras.length > 1) {
          cameraToggle.classList.remove('hidden');
        } else {
          cameraToggle.classList.add('hidden');
        }
        
        // Default cameraFacing logic
        if (availableCameras.length === 1) {
            // If there's only one camera, try to determine its facing mode
            const caps = availableCameras[0].getCapabilities ? availableCameras[0].getCapabilities() : null;
            if (caps && caps.facingMode && Array.isArray(caps.facingMode)) {
                if (caps.facingMode.includes('user')) {
                    cameraFacing = 'user';
                } else if (caps.facingMode.length > 0) {
                    cameraFacing = caps.facingMode[0]; // Use the first available one
                } else {
                    cameraFacing = 'environment'; // Fallback if facingMode array is empty
                }
            } else {
                 cameraFacing = 'environment'; // Fallback if no capabilities or facingMode info
            }
        } else if (availableCameras.length === 0) {
            console.log("No video input devices found.");
            // cameraFacing remains 'environment' by default.
            // startCameraWithFacing will likely fail later and show an error if no cameras.
        }
        // If multiple cameras, cameraFacing remains 'environment' by default, user can toggle.

        updateCameraToggleText();

      } catch (error) {
        console.error('Error enumerating devices (raw error object):', error); // Log the raw error
        let userMessage = 'Could not list cameras. Please check browser permissions and ensure your camera is not in use by another app. Measurement may not work.';
        
        // Try to get more specific info, but prepare for empty error object
        if (error) {
            if (error.name && error.message) {
                userMessage = `Error listing cameras: ${error.name} (${error.message}). Check permissions.`;
            } else if (error.name) {
                 userMessage = `Error listing cameras: ${error.name}. Check permissions.`;
            } else if (typeof error === 'object' && Object.keys(error).length === 0) {
                // This specifically handles the case where error is {}
                userMessage = 'An unknown error occurred while trying to list cameras. Please check browser permissions and ensure your camera is not in use. Measurement may not work.';
            } else if (typeof error === 'string' && error.length > 0){
                userMessage = `Error listing cameras: ${error}. Check permissions.`;
            }
        }
        showCameraError(userMessage);
        availableCameras = []; // Ensure it's empty on error
        cameraToggle.classList.add('hidden'); // Hide toggle on error
        updateCameraToggleText(); // Reflect that no cameras are available for toggle
      }
    }
    
    // Update camera toggle button text
    function updateCameraToggleText() {
      // Text changes based on current cameraFacing and if toggle is visible
      // If cameraToggle is hidden (e.g. only one camera or error), this text might not be seen, but good to keep it consistent.
      cameraToggle.innerHTML = `
        <svg class="icon icon-sm" viewBox="0 0 24 24">
          <path d="M23 4v6h-6"></path>
          <path d="M1 20v-6h6"></path>
          <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
          <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
        </svg>
        Switch to ${cameraFacing === 'environment' ? 'front' : 'back'} camera
      `;
    }
    
    // Toggle between front and back cameras
    function toggleCamera() {
      // Stop current stream if exists
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null; // Important to nullify after stopping
      }
      
      cameraFacing = cameraFacing === 'environment' ? 'user' : 'environment';
      updateCameraToggleText();
      
      // If currently measuring, restart the camera with new facing mode
      if (measuring) { 
        startCameraWithFacing(cameraFacing).catch(err => {
            console.error("Error restarting camera after toggle:", err);
            showCameraError("Failed to switch camera. Please try remeasuring.");
            stopMeasuring(); 
            initialState.classList.remove('hidden'); 
            measuringState.classList.add('hidden');
            resultsState.classList.add('hidden');
        });
      }
    }
    
    // Start camera with specific facing mode
    async function startCameraWithFacing(facing) {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showCameraError("Your browser doesn't support camera access (getUserMedia).");
        return false;
      }
      try {
        cameraError.classList.add('hidden'); 
        
        const constraints = {
          video: {
            facingMode: facing,
            width: { ideal: 640 },
            height: { ideal: 480 },
            frameRate: { ideal: FPS }
          }
        };
        
        const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
        stream = mediaStream; 
        
        processingVideo.srcObject = mediaStream;
        await processingVideo.play();
        
        previewVideo.srcObject = mediaStream;
        await previewVideo.play();
        
        return true; 
      } catch (error) {
        console.error(`Error accessing ${facing} camera:`, error.name, error.message, error);
        
        let userErrorMessage = `Unable to access ${facing} camera. Please check permissions.`;
        if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
            userErrorMessage = `No ${facing} camera found. Try switching cameras or ensure it's connected.`;
        } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            userErrorMessage = `Permission to use the camera was denied. Please allow camera access in your browser settings.`;
        } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
             userErrorMessage = `The ${facing} camera does not support the required settings (e.g., resolution).`;
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
            userErrorMessage = `The camera is currently in use by another application or a hardware error occurred.`;
        }


        // If failed with environment facing and it's not the only option, try user facing
        if (facing === 'environment' && availableCameras.some(cam => {
            const caps = cam.getCapabilities ? cam.getCapabilities() : {};
            return caps.facingMode && caps.facingMode.includes('user');
        })) {
          console.log('Trying user-facing camera as fallback...');
          cameraFacing = 'user'; 
          updateCameraToggleText();
          try {
            const success = await startCameraWithFacing('user'); 
            return success;
          } catch (err) { 
            showCameraError(userErrorMessage); // Show the more specific error from the initial attempt
            return false;
          }
        } else { 
          showCameraError(userErrorMessage);
          return false;
        }
      }
    }
    
    // Show camera error message
    function showCameraError(message) {
      cameraError.textContent = message;
      cameraError.classList.remove('hidden');
    }
    
    // Create and add finger guidance elements
    function setupFingerGuidance() {
      const previewContainer = document.getElementById('previewContainer');
      
      // Create target area element if it doesn't exist
      if (!targetArea) {
        targetArea = document.createElement('div');
        targetArea.className = 'target-area';
        previewContainer.appendChild(targetArea);
      }
      
      // Create finger dot element if it doesn't exist
      if (!fingerDot) {
        fingerDot = document.createElement('div');
        fingerDot.className = 'finger-dot';
        fingerDot.style.left = '50%';
        fingerDot.style.top = '50%';
        previewContainer.appendChild(fingerDot);
      }
      
      // Create guidance text if it doesn't exist
      if (!previewGuidance) {
        previewGuidance = document.createElement('p');
        previewGuidance.className = 'preview-guidance';
        previewGuidance.textContent = "Position your finger on the target";
        // Insert after preview container
        previewContainer.parentNode.insertBefore(previewGuidance, previewContainer.nextSibling);
      }
    }
    
    // Process video frame to extract red channel average and track finger position
    function processFrame() {
      if (!processingVideo || !processingCanvas || !measuring || !stream || processingVideo.paused || processingVideo.ended) return; 
      
      const video = processingVideo;
      const canvas = processingCanvas;
      const ctx = canvas.getContext('2d', { willReadFrequently: true }); 
      
      if (canvas.width !== 150 || canvas.height !== 150) {
        canvas.width = 150;
        canvas.height = 150;
      }
      
      if (video.videoWidth > 0 && video.videoHeight > 0) {
        const srcX = (video.videoWidth - canvas.width) / 2;
        const srcY = (video.videoHeight - canvas.height) / 2;
        
        ctx.drawImage(
          video, 
          srcX, srcY, canvas.width, canvas.height, // Source rectangle (center crop)
          0, 0, canvas.width, canvas.height    // Destination rectangle
        );
        
        // Track the brightest area (likely the finger)
        const fullPixelData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        let brightestX = 0;
        let brightestY = 0;
        let maxBrightness = 0;
        
        // Scan every 5 pixels to improve performance
        for (let y = 0; y < canvas.height; y += 5) {
          for (let x = 0; x < canvas.width; x += 5) {
            const i = (y * canvas.width + x) * 4;
            const r = fullPixelData[i];
            const g = fullPixelData[i + 1];
            const b = fullPixelData[i + 2];
            
            // Calculate brightness (red channel is most important for PPG)
            const brightness = r * 0.7 + g * 0.2 + b * 0.1;
            
            if (brightness > maxBrightness) {
              maxBrightness = brightness;
              brightestX = x;
              brightestY = y;
            }
          }
        }
        
        // Update the finger dot position
        if (fingerDot && maxBrightness > 100) { // Only track if bright enough
          const previewWidth = previewCanvas.width;
          const previewHeight = previewCanvas.height;
          
          // Scale coordinates from processing canvas to preview canvas
          const scaledX = (brightestX / canvas.width) * previewWidth;
          const scaledY = (brightestY / canvas.height) * previewHeight;
          
          fingerDot.style.left = `${scaledX}px`;
          fingerDot.style.top = `${scaledY}px`;
          
          // Check if finger is in the target area
          const targetCenterX = previewCanvas.width / 2;
          const targetCenterY = previewCanvas.height / 2;
          const distance = Math.sqrt(
            Math.pow(scaledX - targetCenterX, 2) + 
            Math.pow(scaledY - targetCenterY, 2)
          );
          
          // Update guidance message
          if (previewGuidance) {
            if (distance < 25) { // Good position (within 25px of center)
              previewGuidance.textContent = "Perfect! Keep steady";
              previewGuidance.classList.add('good-position');
            } else {
              previewGuidance.textContent = "Move your finger to the target";
              previewGuidance.classList.remove('good-position');
            }
          }
        }
        
        // Extract red channel data from ROI
        const roiX = canvas.width / 2 - 20;
        const roiY = canvas.height / 2 - 20;
        const roiWidth = 40;
        const roiHeight = 40;

        const pixelData = ctx.getImageData(roiX, roiY, roiWidth, roiHeight).data;
        
        let totalRed = 0;
        let pixelCount = 0;
        for (let i = 0; i < pixelData.length; i += 4) {
          totalRed += pixelData[i]; 
          pixelCount++;
        }
        const avgRed = pixelCount > 0 ? totalRed / pixelCount : 0;
        
        redValuesBuffer.push(avgRed);
        
        if (redValuesBuffer.length > BUFFER_SIZE) {
          redValuesBuffer.shift();
        }
        
        dataPoints = [...redValuesBuffer];
        updateVisualization();
      }
      
      if (previewCanvas) {
        const previewCtx = previewCanvas.getContext('2d');
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        
        // No need to draw ROI box since we have the target area element now
        // But we'll keep this for compatibility
        previewCtx.strokeStyle = 'rgba(255, 99, 71, 0.3)';
        previewCtx.lineWidth = 2;
        const previewRoiX = previewCanvas.width / 2 - 20; 
        const previewRoiY = previewCanvas.height / 2 - 20;
        previewCtx.strokeRect(previewRoiX, previewRoiY, 40, 40);
      }
      
      frameProcessorId = requestAnimationFrame(processFrame);
    }
    
    // Calculate heart rate from red values with improved signal processing
    function calculateHeartRate() {
      if (redValuesBuffer.length < FPS * 3) { 
        console.warn("Not enough data to calculate heart rate.");
        return null; 
      }
      
      // Step 1: Calculate mean for normalization
      const mean = redValuesBuffer.reduce((sum, val) => sum + val, 0) / redValuesBuffer.length;
      const normalizedValues = redValuesBuffer.map(val => val - mean);
      
      // Step 2: Apply moving average filter to reduce noise
      const windowSize = 3; // Small window to preserve peaks but reduce noise
      const filteredValues = [];
      for (let i = 0; i < normalizedValues.length; i++) {
        let sum = 0;
        let count = 0;
        for (let j = Math.max(0, i - windowSize); j <= Math.min(normalizedValues.length - 1, i + windowSize); j++) {
          sum += normalizedValues[j];
          count++;
        }
        filteredValues.push(sum / count);
      }
      
      // Step 3: Calculate signal quality metrics
      const variance = filteredValues.reduce((sum, val) => sum + val * val, 0) / filteredValues.length;
      const prevSignalQuality = signalQuality;
      
      if (variance > 30) {
        signalQuality = 'Good';
      } else if (variance > 10) {
        signalQuality = 'Fair';
      } else {
        signalQuality = 'Poor';
      }
      
      // Update UI if signal quality changed
      if (signalQuality !== prevSignalQuality) {
        updateSignalQualityUI();
      }
      
      console.log(`Signal quality: ${signalQuality} (variance: ${variance.toFixed(2)})`);
      
      // Step 4: Adaptive peak detection
      const peaks = [];
      if (filteredValues.length === 0) return null;
      
      const maxValue = Math.max(...filteredValues);
      const minValue = Math.min(...filteredValues);
      const range = maxValue - minValue;
      
      // Adaptive threshold based on signal quality and range
      let peakThresholdPercent = 0.3; // Default 30%
      if (signalQuality === 'Poor') peakThresholdPercent = 0.2; // Lower threshold for poor signal
      if (signalQuality === 'Good') peakThresholdPercent = 0.35; // Higher threshold for good signal
      
      const peakThreshold = range * peakThresholdPercent;
      
      // Minimum distance between peaks in frames (to avoid double counting)
      const minPeakDistance = Math.floor(FPS * 0.5); // ~0.5 seconds minimum between peaks
      let lastPeakIndex = -minPeakDistance;
      
      for (let i = 2; i < filteredValues.length - 2; i++) {
        // Check if this point is a local maximum in a 5-point window
        if (filteredValues[i] > filteredValues[i-1] && 
            filteredValues[i] > filteredValues[i-2] &&
            filteredValues[i] > filteredValues[i+1] && 
            filteredValues[i] > filteredValues[i+2] &&
            filteredValues[i] > peakThreshold && 
            i - lastPeakIndex >= minPeakDistance) {
          
          peaks.push(i);
          lastPeakIndex = i;
        }
      }
      
      if (peaks.length < 2) {
        console.warn(`Not enough peaks detected (found ${peaks.length}) for signal quality: ${signalQuality}`);
        return null; 
      }
      
      // Step 5: Calculate intervals between peaks
      const intervals = [];
      for (let i = 1; i < peaks.length; i++) {
        intervals.push(peaks[i] - peaks[i-1]);
      }
      
      // Remove outlier intervals (those that deviate significantly from median)
      const sortedIntervals = [...intervals].sort((a, b) => a - b);
      const medianInterval = sortedIntervals[Math.floor(sortedIntervals.length / 2)];
      
      const validIntervals = intervals.filter(interval => 
        interval >= medianInterval * 0.7 && interval <= medianInterval * 1.3
      );
      
      if (validIntervals.length < intervals.length * 0.5) {
        console.warn("Too many irregular intervals detected, possible unreliable signal");
        if (signalQuality === 'Poor') return null;
      }
      
      const avgInterval = validIntervals.length > 0 
        ? validIntervals.reduce((sum, val) => sum + val, 0) / validIntervals.length 
        : medianInterval;
      
      if (avgInterval === 0) return null; // Avoid division by zero
      
      // Step 6: Convert to heart rate
      const heartRate = Math.round((FPS * 60) / avgInterval);
      
      // Validate result is physiologically plausible
      if (heartRate >= 40 && heartRate <= 220) {
        return heartRate;
      } else {
        console.warn(`Calculated heart rate (${heartRate} BPM) is outside typical range.`);
        return null; 
      }
    }
    
    // Update signal quality UI indicator
    function updateSignalQualityUI() {
      if (!signalQualityElement || !qualityValueElement) return;
      
      // Show signal quality element
      signalQualityElement.classList.remove('hidden');
      
      // Update text
      qualityValueElement.textContent = signalQuality;
      
      // Update indicator color
      const qualityIndicator = signalQualityElement.querySelector('.quality-indicator');
      if (qualityIndicator) {
        qualityIndicator.className = 'quality-indicator';
        if (signalQuality === 'Good') {
          qualityIndicator.classList.add('quality-good');
        } else if (signalQuality === 'Fair') {
          qualityIndicator.classList.add('quality-fair');
        } else {
          qualityIndicator.classList.add('quality-poor');
        }
      }
    }
    
    // Enhanced visualization with peak detection
    function updateVisualization() {
      visualization.innerHTML = ''; 
      
      const displayPoints = dataPoints.slice(-100); 
      if (displayPoints.length === 0) return;

      const minVal = Math.min(...displayPoints); 
      const maxVal = Math.max(...displayPoints); 
      const range = (maxVal - minVal) === 0 ? 1 : (maxVal - minVal); 

      // Filter points for visualization
      const mean = displayPoints.reduce((sum, val) => sum + val, 0) / displayPoints.length;
      const normalizedPoints = displayPoints.map(val => val - mean);
      
      // Apply simple moving average filter for visualization
      const windowSize = 3;
      const filteredPoints = [];
      for (let i = 0; i < normalizedPoints.length; i++) {
        let sum = 0;
        let count = 0;
        for (let j = Math.max(0, i - windowSize); j <= Math.min(normalizedPoints.length - 1, i + windowSize); j++) {
          sum += normalizedPoints[j];
          count++;
        }
        filteredPoints.push(sum / count);
      }
      
      // Find peaks for visualization
      const visualPeaks = [];
      const maxFiltered = Math.max(...filteredPoints);
      const peakThreshold = maxFiltered * 0.3;
      
      for (let i = 2; i < filteredPoints.length - 2; i++) {
        if (filteredPoints[i] > filteredPoints[i-1] && 
            filteredPoints[i] > filteredPoints[i-2] &&
            filteredPoints[i] > filteredPoints[i+1] && 
            filteredPoints[i] > filteredPoints[i+2] &&
            filteredPoints[i] > peakThreshold) {
          visualPeaks.push(i);
        }
      }

      for (let i = 0; i < displayPoints.length; i++) {
        const value = displayPoints[i];
        const normalizedValue = ((value - minVal) / range) * 100; 
        const height = Math.max(1, Math.min(100, normalizedValue)); 
        
        const bar = document.createElement('div');
        bar.className = 'visualization-bar';
        bar.style.height = `${height}%`;
        bar.style.left = `${(i / displayPoints.length) * 100}%`; 
        bar.style.width = `${Math.max(1, 100 / displayPoints.length)}%`;
        
        // Highlight peaks in the visualization
        if (visualPeaks.includes(i)) {
          bar.classList.add('peak');
        }

        visualization.appendChild(bar);
      }
    }
    
    // Clear visualization
    function clearVisualization() {
      visualization.innerHTML = '';
      dataPoints = []; 
    }
    
    // Start measurement process
    async function startMeasurement() {
      measuring = true;
      countdown = 5; 
      redValuesBuffer = [];
      dataPoints = []; 
      measurementNumber = 0; 
      individualReadings = [];
      signalQuality = 'Unknown'; // Reset signal quality
      
      initialState.classList.add('hidden');
      resultsState.classList.add('hidden');
      measuringState.classList.remove('hidden');
      cameraError.classList.add('hidden'); // Hide any previous errors
      
      countdownElement.textContent = countdown;
      countdownElement.classList.add('pulse'); 
      clearVisualization();
      updateMeasurementIndicators(); 
      clearReadings();
      signalQualityElement.classList.add('hidden'); // Hide signal quality initially
      
      // Setup finger guidance
      setupFingerGuidance();
      
      try {
        const cameraStarted = await startCameraWithFacing(cameraFacing);
        
        if (!cameraStarted) {
          stopMeasuring(); 
          initialState.classList.remove('hidden'); 
          measuringState.classList.add('hidden'); 
          // Error message is shown by startCameraWithFacing
          return; 
        }
        
        let countdownTimer = setInterval(() => {
          countdown--;
          countdownElement.textContent = countdown;
          
          if (countdown <= 0) {
            clearInterval(countdownTimer);
            countdownTimer = null; // Clear interval ID
            countdownElement.classList.remove('pulse'); 
            measurementNumber = 1; 
            startSingleMeasurement();
          }
        }, 1000);
      } catch (error) { 
        console.error('Error starting measurement process:', error);
        showCameraError('An unexpected error occurred while starting measurement.');
        stopMeasuring();
        initialState.classList.remove('hidden');
        measuringState.classList.add('hidden');
      }
    }
    
    // Start a single measurement with auto-calibration
    function startSingleMeasurement() {
      countdownElement.textContent = `${measurementNumber}/${TOTAL_MEASUREMENTS}`;
      updateMeasurementIndicators(); 
      
      redValuesBuffer = [];
      
      if (frameProcessorId) cancelAnimationFrame(frameProcessorId); 
      frameProcessorId = requestAnimationFrame(processFrame);
      
      // Auto-calibration period
      setTimeout(() => {
        // After calibration time, check if we have enough data
        if (redValuesBuffer.length > FPS * CALIBRATION_DURATION) {
          // Calculate initial signal quality to adjust measurement parameters
          const mean = redValuesBuffer.reduce((sum, val) => sum + val, 0) / redValuesBuffer.length;
          const normalizedValues = redValuesBuffer.map(val => val - mean);
          const variance = normalizedValues.reduce((sum, val) => sum + val * val, 0) / normalizedValues.length;
          
          // Set initial signal quality
          if (variance > 30) {
            signalQuality = 'Good';
          } else if (variance > 10) {
            signalQuality = 'Fair';
          } else {
            signalQuality = 'Poor';
          }
          
          updateSignalQualityUI();
          console.log(`Calibration complete. Signal quality: ${signalQuality} (variance: ${variance.toFixed(2)})`);
          
          // Optionally adjust measurement duration based on initial signal quality
          let adjustedDuration = MEASUREMENT_DURATION;
          if (signalQuality === 'Poor') { 
            adjustedDuration = Math.min(MEASUREMENT_DURATION + 2, 12); // Add up to 2 seconds, max 12 seconds
            console.log(`Signal quality is poor. Extended measurement duration to ${adjustedDuration}s`);
          }
          
          // Continue with the actual measurement
          setTimeout(() => {
            if (frameProcessorId) {
              cancelAnimationFrame(frameProcessorId);
              frameProcessorId = null;
            }
            
            const hr = calculateHeartRate();
            const newReading = (hr !== null) ? hr : FAILED_MEASUREMENT_TEXT;
            individualReadings.push(newReading);
            
            updateReadings(); 
            updateMeasurementIndicators(); 
            
            if (measurementNumber < TOTAL_MEASUREMENTS) {
              measurementNumber++; 
              setTimeout(() => {
                startSingleMeasurement();
              }, 1000); 
            } else {
              // Finalize measurements
              finalizeMeasurements();
            }
          }, (adjustedDuration - CALIBRATION_DURATION) * 1000);
          
        } else {
          // Fallback if calibration failed
          console.warn("Not enough data for calibration, proceeding with default parameters");
          
          // Continue with standard measurement duration
          setTimeout(() => {
            if (frameProcessorId) {
              cancelAnimationFrame(frameProcessorId);
              frameProcessorId = null;
            }
            
            const hr = calculateHeartRate();
            const newReading = (hr !== null) ? hr : FAILED_MEASUREMENT_TEXT;
            individualReadings.push(newReading);
            
            updateReadings(); 
            updateMeasurementIndicators(); 
            
            if (measurementNumber < TOTAL_MEASUREMENTS) {
              measurementNumber++; 
              setTimeout(() => {
                startSingleMeasurement();
              }, 1000); 
            } else {
              // Finalize measurements
              finalizeMeasurements();
            }
          }, MEASUREMENT_DURATION * 1000);
        }
      }, CALIBRATION_DURATION * 1000);
    }
    
    // Finalize measurements and show results
    function finalizeMeasurements() {
      const validReadings = individualReadings.filter(r => typeof r === 'number' && r >= 40 && r <= 220);
      
      let finalHR;
      if (validReadings.length > 0) {
        const sortedReadings = [...validReadings].sort((a, b) => a - b);
        finalHR = sortedReadings[Math.floor(sortedReadings.length / 2)];
      } else {
        finalHR = FAILED_MEASUREMENT_TEXT; 
      }
      
      heartRate = finalHR; 
      
      if (typeof heartRate === 'number') {
        recommendedTempo = Math.floor(heartRate * 0.7);
        tempoValue.textContent = `${recommendedTempo} BPM`;
        currentTempo.textContent = recommendedTempo;
        startSessionBtn.disabled = false; 
        startSessionBtn.classList.remove('btn-disabled'); 
      } else {
        recommendedTempo = FAILED_MEASUREMENT_TEXT; 
        tempoValue.textContent = "N/A";
        currentTempo.textContent = "N/A";
        startSessionBtn.disabled = true; 
        startSessionBtn.classList.add('btn-disabled'); 
      }
      
      heartRateValue.textContent = (typeof heartRate === 'number') ? `${heartRate} BPM` : "Measurement Failed";
      updateResultReadings(); 
      
      measuringState.classList.add('hidden');
      resultsState.classList.remove('hidden');
      
      stopMeasuring(); 
    }
    
    // Stop measuring and clean up
    function stopMeasuring() {
      measuring = false; 
      
      if (frameProcessorId) {
        cancelAnimationFrame(frameProcessorId);
        frameProcessorId = null;
      }
      
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null; 
      }
      
      // Reset the guidance elements
      if (fingerDot) {
        fingerDot.style.left = '50%';
        fingerDot.style.top = '50%';
      }
      
      if (previewGuidance) {
        previewGuidance.textContent = "Position your finger on the target";
        previewGuidance.classList.remove('good-position');
      }
    }
    
    // Update readings display during measurement
    function updateReadings() {
      readings.innerHTML = ''; 
      
      individualReadings.forEach((reading) => {
        const readingElement = document.createElement('div');
        readingElement.className = 'reading';
        
        if (reading === FAILED_MEASUREMENT_TEXT) {
          readingElement.innerHTML = `<span class="reading-value">${FAILED_MEASUREMENT_TEXT}</span>`;
        } else {
          readingElement.innerHTML = `
            <span class="reading-value">${reading}</span>
            <span class="reading-unit">&nbsp;BPM</span>
          `;
        }
        readings.appendChild(readingElement);
      });
    }
    
    // Clear readings display
    function clearReadings() {
      readings.innerHTML = '';
    }
    
    // Update result readings display after all measurements
    function updateResultReadings() {
      resultReadings.innerHTML = ''; 
      
      individualReadings.forEach((reading) => {
        const readingElement = document.createElement('div');
        readingElement.className = 'result-reading';
        
        let iconSvg = '';
        let readingText = '';

        if (reading === FAILED_MEASUREMENT_TEXT) {
          iconSvg = `
            <svg class="icon icon-xs" viewBox="0 0 24 24" style="color: #ef4444; margin-right: 4px;">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          `;
          readingText = FAILED_MEASUREMENT_TEXT;
        } else {
          iconSvg = `
            <svg class="icon icon-xs" viewBox="0 0 24 24" style="color: #10b981; margin-right: 4px;">
              <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
          `;
          readingText = `${reading} BPM`;
        }
        
        readingElement.innerHTML = iconSvg + readingText;
        resultReadings.appendChild(readingElement);
      });
    }
    
    // Update measurement indicators
    function updateMeasurementIndicators() {
      const indicators = measurementIndicators.querySelectorAll('.indicator');
      
      for (let i = 0; i < indicators.length; i++) {
        indicators[i].className = 'indicator'; // Reset classes
        
        // Check if there's a reading for this indicator's measurement
        if (i < individualReadings.length) { // This measurement has been attempted
            if (individualReadings[i] === FAILED_MEASUREMENT_TEXT) {
                indicators[i].classList.add('failed');
            } else {
                indicators[i].classList.add('complete');
            }
        } else if (i === measurementNumber -1 && measuring) { // Current measurement in progress
            indicators[i].classList.add('active');
        }
        // Indicators for future measurements remain default gray
      }
    }
    
    // Simulate data points for testing
    function simulateDataPoints() {
      redValuesBuffer = []; 
      const baseValue = 150;
      const amplitude = 30;
      const frequency = 1.2; 
      const durationSeconds = 3; 
      const numPoints = FPS * durationSeconds;

      for (let i = 0; i < numPoints; i++) {
        const time = i / FPS; 
        const pulse = Math.sin(time * Math.PI * 2 * frequency) * amplitude;
        const noise = Math.random() * 10 - 5; 
        redValuesBuffer.push(baseValue + pulse + noise);
      }
      
      dataPoints = [...redValuesBuffer]; 
      updateVisualization(); 
      
      let animationFrameCount = 0;
      function animateSimulatedData() {
        if (!measuring || redValuesBuffer.length === 0) return; 

        redValuesBuffer.shift();
        const time = (numPoints + animationFrameCount) / FPS; 
        const pulse = Math.sin(time * Math.PI * 2 * frequency) * amplitude;
        const noise = Math.random() * 10 - 5;
        redValuesBuffer.push(baseValue + pulse + noise);
        
        dataPoints = [...redValuesBuffer];
        updateVisualization();
        animationFrameCount++;
        
        if (measuring) { 
          frameProcessorId = requestAnimationFrame(animateSimulatedData);
        }
      }
      if (measuring) { 
        frameProcessorId = requestAnimationFrame(animateSimulatedData);
      }
    }
    
    // Start meditation session
    function startMeditation() {
      if (typeof heartRate !== 'number' || meditationActive) return; 

      meditationActive = true;
      progress = 0;
      
      startSessionBtn.classList.add('hidden');
      endSessionBtn.classList.remove('hidden');
      meditationSection.classList.remove('hidden');
      progressFill.style.width = '0%';
      
      const totalMeditationDurationMs = 10 * 60 * 1000; 
      const progressUpdateIntervalMs = totalMeditationDurationMs / 100; 

      animationId = setInterval(() => {
        progress += 1;
        progressFill.style.width = `${progress}%`;
        
        if (progress >= 100) {
          endMeditation();
        }
      }, progressUpdateIntervalMs); 
    }
    
    // End meditation session
    function endMeditation() {
      meditationActive = false;
      
      startSessionBtn.classList.remove('hidden');
      endSessionBtn.classList.add('hidden');
      
      if (animationId) {
        clearInterval(animationId);
        animationId = null;
      }
    }
    
    // Event listeners
    document.addEventListener('DOMContentLoaded', function() {
      checkCameras(); 
      
      startMeasurementBtn.addEventListener('click', startMeasurement);
      cameraToggle.addEventListener('click', toggleCamera);
      remeasureBtn.addEventListener('click', startMeasurement); 
      startSessionBtn.addEventListener('click', startMeditation);
      endSessionBtn.addEventListener('click', endMeditation);
    });
    
    // Clean up on page unload
    window.addEventListener('beforeunload', function() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      
      if (frameProcessorId) {
        cancelAnimationFrame(frameProcessorId);
        frameProcessorId = null;
      }
      
      if (animationId) { 
        clearInterval(animationId);
        animationId = null;
      }
    });
  </script>
</body>
</html>
