<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rhythm Breath - Heart Rate Based Meditation</title>
  <style>
    /* Base styles */
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f3f4f6;
      color: #374151;
    }
    
    .container {
      max-width: 480px;
      margin: 0 auto;
      padding: 24px;
    }
    
    .hidden {
      display: none !important;
    }
    
    /* Header */
    .header {
      text-align: center;
      margin-bottom: 24px;
    }
    
    .app-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: #4f46e5;
      margin-bottom: 8px;
    }
    
    .app-subtitle {
      color: #6b7280;
      font-size: 0.9rem;
      margin-top: 0;
    }
    
    /* Main card */
    .card {
      background-color: white;
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      margin-bottom: 24px;
      text-align: center;
    }
    
    /* Camera section */
    .camera-icon {
      background-color: #fee2e2;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 16px auto;
    }
    
    .camera-instruction {
      margin-bottom: 16px;
    }
    
    .camera-toggle {
      background: none;
      border: none;
      color: #4f46e5;
      font-size: 0.875rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      margin: 0 auto 16px auto;
    }
    
    .camera-toggle svg {
      margin-right: 4px;
    }
    
    .camera-error {
      color: #ef4444;
      font-size: 0.875rem;
      margin-bottom: 16px;
    }
    
    /* Camera preview */
    .preview-container {
      position: relative;
      width: 128px;
      height: 128px;
      margin: 0 auto 16px auto;
    }
    
    .camera-preview {
      width: 128px;
      height: 128px;
      border-radius: 8px;
      border: 2px solid #f87171;
      object-fit: cover;
    }
    
    .preview-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    .preview-help {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 4px;
    }
    
    /* Countdown */
    .countdown {
      width: 64px;
      height: 64px;
      background-color: #ef4444;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 700;
      font-size: 1.25rem;
      margin: 0 auto 8px auto;
    }
    
    .countdown.pulse {
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% {
        transform: scale(0.95);
        box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);
      }
      
      70% {
        transform: scale(1);
        box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
      }
      
      100% {
        transform: scale(0.95);
        box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);
      }
    }
    
    .keep-steady {
      margin-bottom: 8px;
    }
    
    /* Measurement indicators */
    .measurement-indicators {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 8px;
    }
    
    .indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: #d1d5db; /* Default gray */
    }
    
    .indicator.active {
      background-color: #ef4444; /* Red for active */
      animation: pulse 1.5s infinite;
    }
    
    .indicator.complete {
      background-color: #10b981; /* Green for complete */
    }

    .indicator.failed {
      background-color: #f59e0b; /* Amber/Orange for failed */
    }
    
    /* Readings display */
    .readings {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-top: 12px;
      font-size: 0.75rem;
    }
    
    .reading {
      display: flex;
      align-items: center;
    }
    
    .reading-value {
      font-weight: 500;
    }
    
    .reading-unit {
      color: #6b7280;
    }
    
    /* Signal visualization */
    .visualization {
      height: 64px;
      width: 100%;
      background-color: #f3f4f6;
      position: relative;
      overflow: hidden;
      margin-top: 16px;
    }
    
    .visualization-bar {
      position: absolute;
      bottom: 0;
      width: 4px;
      background-color: #ef4444;
      opacity: 0.7;
    }
    
    /* Results */
    .heart-rate {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 8px;
    }
    
    .heart-rate-value {
      font-size: 1.5rem;
      font-weight: 700;
      margin-left: 8px;
    }
    
    .result-readings {
      display: flex;
      justify-content: center;
      flex-wrap: wrap; /* Allow readings to wrap if many */
      margin-bottom: 16px;
      font-size: 0.875rem;
    }
    
    .result-reading {
      margin: 0 8px;
      display: flex;
      align-items: center;
    }
    
    .tempo-box {
      background-color: #eef2ff;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 16px;
    }
    
    .tempo-value {
      font-weight: 700;
    }
    
    .tempo-note {
      font-size: 0.875rem;
      color: #6b7280;
      margin-top: 4px;
    }
    
    /* Buttons */
    .btn {
      padding: 8px 24px;
      border-radius: 8px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s ease;
      border: none;
      display: inline-flex;
      align-items: center;
    }
    
    .btn-primary {
      background-color: #4f46e5;
      color: white;
    }
    
    .btn-primary:hover {
      background-color: #4338ca;
    }
    
    .btn-success {
      background-color: #10b981;
      color: white;
    }
    
    .btn-success:hover {
      background-color: #059669;
    }
     .btn-success.btn-disabled {
      background-color: #a0aec0; /* Example disabled color */
      cursor: not-allowed;
    }
    
    .btn-danger {
      background-color: #ef4444;
      color: white;
    }
    
    .btn-danger:hover {
      background-color: #dc2626;
    }
    
    .btn-link {
      background: none;
      color: #4f46e5;
      padding: 0;
    }
    
    .btn-link:hover {
      color: #4338ca;
    }
    
    .btn svg {
      margin-right: 4px;
    }
    
    /* Meditation progress */
    .meditation-section {
      margin-bottom: 24px;
    }
    
    .progress-bar {
      height: 12px;
      background-color: #e5e7eb;
      border-radius: 999px;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background-color: #10b981;
      transition: width 0.3s ease-out;
    }
    
    .progress-times {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 4px;
    }
    
    .current-track {
      font-size: 0.875rem;
      color: #6b7280;
      margin-top: 8px;
    }
    
    .track-name {
      font-weight: 500;
    }
    
    /* Info box */
    .info-box {
      background-color: #eef2ff;
      padding: 16px;
      border-radius: 8px;
    }
    
    .info-title {
      font-weight: 600;
      color: #1e40af;
      margin-top: 0;
      margin-bottom: 8px;
    }
    
    .info-text {
      font-size: 0.875rem;
      color: #4b5563;
      margin: 0;
    }

    /* Icons */
    .icon {
      display: inline-block;
      width: 24px;
      height: 24px;
      stroke-width: 2;
      stroke: currentColor;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    
    .icon-sm {
      width: 16px;
      height: 16px;
    }
    
    .icon-xs {
      width: 12px;
      height: 12px;
    }
    
    .icon-lg {
      width: 48px;
      height: 48px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1 class="app-title">Rhythm Breath</h1>
      <p class="app-subtitle">Personalized meditation based on your heart rhythm</p>
    </div>
    
    <div class="hidden">
      <video id="processingVideo" playsinline muted></video>
      <canvas id="processingCanvas"></canvas>
    </div>
    
    <div class="card" id="mainCard">
      <div id="initialState">
        <div class="camera-icon">
          <svg class="icon icon-lg" viewBox="0 0 24 24">
            <rect x="2" y="6" width="20" height="12" rx="2" ry="2"></rect>
            <circle cx="12" cy="12" r="3"></circle>
          </svg>
        </div>
        <p class="camera-instruction">Place your thumb over your camera lens to measure your heart rate</p>
        
        <button id="cameraToggle" class="camera-toggle hidden">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <path d="M23 4v6h-6"></path>
            <path d="M1 20v-6h6"></path>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
            <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
          </svg>
          Switch to front camera
        </button>
        
        <div id="cameraError" class="camera-error hidden"></div>
        
        <button id="startMeasurementBtn" class="btn btn-primary">Start Measurement</button>
      </div>
      
      <div id="measuringState" class="hidden">
        <div class="preview-container" id="previewContainer">
          <video id="previewVideo" class="camera-preview" playsinline muted autoplay></video>
          <canvas id="previewCanvas" class="preview-overlay" width="128" height="128"></canvas>
          <div class="preview-help">Center your fingertip in the red box</div>
        </div>
        
        <div id="countdown" class="countdown pulse">5</div>
        <p class="keep-steady">Keep your thumb steady...</p>
        
        <div class="measurement-indicators" id="measurementIndicators">
          <div class="indicator"></div>
          <div class="indicator"></div>
          <div class="indicator"></div>
        </div>
        
        <div id="readings" class="readings"></div>
        
        <div id="visualization" class="visualization"></div>
      </div>
      
      <div id="resultsState" class="hidden">
        <div class="heart-rate">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M22 12h-4l-3 9L9 3l-3 9H2"></path>
          </svg>
          <span id="heartRateValue" class="heart-rate-value">72 BPM</span>
        </div>
        
        <div id="resultReadings" class="result-readings"></div>
        
        <div class="tempo-box">
          <p>Recommended music tempo: <span id="tempoValue" class="tempo-value">60 BPM</span></p>
          <p class="tempo-note">Music at this tempo will help guide your heart rate toward a more relaxed state</p>
        </div>
        
        <button id="remeasureBtn" class="btn btn-link">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <path d="M23 4v6h-6"></path>
            <path d="M1 20v-6h6"></path>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
            <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
          </svg>
          Re-measure
        </button>
        
        <button id="startSessionBtn" class="btn btn-success">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
          </svg>
          Start Session
        </button>
        
        <button id="endSessionBtn" class="btn btn-danger hidden">
          <svg class="icon icon-sm" viewBox="0 0 24 24">
            <rect x="6" y="4" width="4" height="16"></rect>
            <rect x="14" y="4" width="4" height="16"></rect>
          </svg>
          End Session
        </button>
      </div>
    </div>
    
    <div id="meditationSection" class="meditation-section hidden">
      <div class="progress-bar">
        <div id="progressFill" class="progress-fill" style="width: 0%"></div>
      </div>
      <div class="progress-times">
        <span>0:00</span>
        <span>10:00</span>
      </div>
      <p class="current-track">
        Currently playing: <span class="track-name">Ocean Calm</span> (<span id="currentTempo">60</span> BPM)
      </p>
    </div>
    
    <div class="info-box">
      <h3 class="info-title">How it works</h3>
      <p class="info-text">
        We use your device's camera to capture subtle color changes in your fingertip
        that correspond to your pulse. We take 3 measurements to ensure accuracy,
        extract the red channel data, analyze the waveform to detect peaks,
        and calculate your heart rate. Then we generate meditation music with a 
        tempo designed to guide you toward a more peaceful state.
      </p>
    </div>
  </div>

  <script>
    // Configuration
    const FPS = 30;
    const MEASUREMENT_DURATION = 8; // seconds
    const BUFFER_SIZE = FPS * MEASUREMENT_DURATION;
    const TOTAL_MEASUREMENTS = 3;
    const FAILED_MEASUREMENT_TEXT = "Failed"; // Constant for failed measurement
    
    // State variables
    let measuring = false;
    let heartRate = null;
    let recommendedTempo = null;
    let countdown = 5;
    let meditationActive = false;
    let progress = 0;
    let dataPoints = [];
    let stream = null;
    let measurementNumber = 0;
    let individualReadings = []; // Can now store numbers or FAILED_MEASUREMENT_TEXT
    let cameraFacing = 'environment'; // 'environment' for back, 'user' for front
    let availableCameras = [];
    
    // References to DOM elements
    const initialState = document.getElementById('initialState');
    const measuringState = document.getElementById('measuringState');
    const resultsState = document.getElementById('resultsState');
    const meditationSection = document.getElementById('meditationSection');
    
    const processingVideo = document.getElementById('processingVideo');
    const processingCanvas = document.getElementById('processingCanvas');
    const previewVideo = document.getElementById('previewVideo');
    const previewCanvas = document.getElementById('previewCanvas');
    
    const startMeasurementBtn = document.getElementById('startMeasurementBtn');
    const cameraToggle = document.getElementById('cameraToggle');
    const cameraError = document.getElementById('cameraError');
    const countdownElement = document.getElementById('countdown');
    const measurementIndicators = document.getElementById('measurementIndicators');
    const readings = document.getElementById('readings');
    const visualization = document.getElementById('visualization');
    
    const heartRateValue = document.getElementById('heartRateValue');
    const resultReadings = document.getElementById('resultReadings');
    const tempoValue = document.getElementById('tempoValue');
    const remeasureBtn = document.getElementById('remeasureBtn');
    const startSessionBtn = document.getElementById('startSessionBtn');
    const endSessionBtn = document.getElementById('endSessionBtn');
    
    const progressFill = document.getElementById('progressFill');
    const currentTempo = document.getElementById('currentTempo');
    
    // Variables for processing
    let redValuesBuffer = [];
    let frameProcessorId = null;
    let animationId = null;
    
    // Check available cameras on page load
    async function checkCameras() {
      // First, check if the MediaDevices API and enumerateDevices are supported
      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
        console.error("MediaDevices API or enumerateDevices not supported.");
        showCameraError("Camera features are not supported by your browser or device.");
        availableCameras = []; // Ensure it's empty
        cameraToggle.classList.add('hidden'); // Explicitly hide toggle
        updateCameraToggleText(); // Update UI based on no cameras
        return;
      }

      try {
        // Get list of media devices
        const devices = await navigator.mediaDevices.enumerateDevices();
        availableCameras = devices.filter(device => device.kind === 'videoinput');
        
        // Show or hide camera toggle based on number of cameras
        if (availableCameras.length > 1) {
          cameraToggle.classList.remove('hidden');
        } else {
          cameraToggle.classList.add('hidden');
        }
        
        // Default cameraFacing logic
        if (availableCameras.length === 1) {
            // If there's only one camera, try to determine its facing mode
            const caps = availableCameras[0].getCapabilities ? availableCameras[0].getCapabilities() : null;
            if (caps && caps.facingMode && Array.isArray(caps.facingMode)) {
                if (caps.facingMode.includes('user')) {
                    cameraFacing = 'user';
                } else if (caps.facingMode.length > 0) {
                    cameraFacing = caps.facingMode[0]; // Use the first available one
                } else {
                    cameraFacing = 'environment'; // Fallback if facingMode array is empty
                }
            } else {
                 cameraFacing = 'environment'; // Fallback if no capabilities or facingMode info
            }
        } else if (availableCameras.length === 0) {
            console.log("No video input devices found.");
            // cameraFacing remains 'environment' by default.
            // startCameraWithFacing will likely fail later and show an error if no cameras.
        }
        // If multiple cameras, cameraFacing remains 'environment' by default, user can toggle.

        updateCameraToggleText();

      } catch (error) {
        console.error('Error enumerating devices (raw error object):', error); // Log the raw error
        let userMessage = 'Could not list cameras. Please check browser permissions and ensure your camera is not in use by another app. Measurement may not work.';
        
        // Try to get more specific info, but prepare for empty error object
        if (error) {
            if (error.name && error.message) {
                userMessage = `Error listing cameras: ${error.name} (${error.message}). Check permissions.`;
            } else if (error.name) {
                 userMessage = `Error listing cameras: ${error.name}. Check permissions.`;
            } else if (typeof error === 'object' && Object.keys(error).length === 0) {
                // This specifically handles the case where error is {}
                userMessage = 'An unknown error occurred while trying to list cameras. Please check browser permissions and ensure your camera is not in use. Measurement may not work.';
            } else if (typeof error === 'string' && error.length > 0){
                userMessage = `Error listing cameras: ${error}. Check permissions.`;
            }
        }
        showCameraError(userMessage);
        availableCameras = []; // Ensure it's empty on error
        cameraToggle.classList.add('hidden'); // Hide toggle on error
        updateCameraToggleText(); // Reflect that no cameras are available for toggle
      }
    }
    
    // Update camera toggle button text
    function updateCameraToggleText() {
      // Text changes based on current cameraFacing and if toggle is visible
      // If cameraToggle is hidden (e.g. only one camera or error), this text might not be seen, but good to keep it consistent.
      cameraToggle.innerHTML = `
        <svg class="icon icon-sm" viewBox="0 0 24 24">
          <path d="M23 4v6h-6"></path>
          <path d="M1 20v-6h6"></path>
          <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
          <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
        </svg>
        Switch to ${cameraFacing === 'environment' ? 'front' : 'back'} camera
      `;
    }
    
    // Toggle between front and back cameras
    function toggleCamera() {
      // Stop current stream if exists
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null; // Important to nullify after stopping
      }
      
      cameraFacing = cameraFacing === 'environment' ? 'user' : 'environment';
      updateCameraToggleText();
      
      // If currently measuring, restart the camera with new facing mode
      if (measuring) { 
        startCameraWithFacing(cameraFacing).catch(err => {
            console.error("Error restarting camera after toggle:", err);
            showCameraError("Failed to switch camera. Please try remeasuring.");
            stopMeasuring(); 
            initialState.classList.remove('hidden'); 
            measuringState.classList.add('hidden');
            resultsState.classList.add('hidden');
        });
      }
    }
    
    // Start camera with specific facing mode
    async function startCameraWithFacing(facing) {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showCameraError("Your browser doesn't support camera access (getUserMedia).");
        return false;
      }
      try {
        cameraError.classList.add('hidden'); 
        
        const constraints = {
          video: {
            facingMode: facing,
            width: { ideal: 640 },
            height: { ideal: 480 },
            frameRate: { ideal: FPS }
          }
        };
        
        const mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
        stream = mediaStream; 
        
        processingVideo.srcObject = mediaStream;
        await processingVideo.play();
        
        previewVideo.srcObject = mediaStream;
        await previewVideo.play();
        
        return true; 
      } catch (error) {
        console.error(`Error accessing ${facing} camera:`, error.name, error.message, error);
        
        let userErrorMessage = `Unable to access ${facing} camera. Please check permissions.`;
        if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
            userErrorMessage = `No ${facing} camera found. Try switching cameras or ensure it's connected.`;
        } else if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            userErrorMessage = `Permission to use the camera was denied. Please allow camera access in your browser settings.`;
        } else if (error.name === 'OverconstrainedError' || error.name === 'ConstraintNotSatisfiedError') {
             userErrorMessage = `The ${facing} camera does not support the required settings (e.g., resolution).`;
        } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
            userErrorMessage = `The camera is currently in use by another application or a hardware error occurred.`;
        }


        // If failed with environment facing and it's not the only option, try user facing
        if (facing === 'environment' && availableCameras.some(cam => {
            const caps = cam.getCapabilities ? cam.getCapabilities() : {};
            return caps.facingMode && caps.facingMode.includes('user');
        })) {
          console.log('Trying user-facing camera as fallback...');
          cameraFacing = 'user'; 
          updateCameraToggleText();
          try {
            const success = await startCameraWithFacing('user'); 
            return success;
          } catch (err) { 
            showCameraError(userErrorMessage); // Show the more specific error from the initial attempt
            return false;
          }
        } else { 
          showCameraError(userErrorMessage);
          return false;
        }
      }
    }
    
    // Show camera error message
    function showCameraError(message) {
      cameraError.textContent = message;
      cameraError.classList.remove('hidden');
    }
    
    // Process video frame to extract red channel average
    function processFrame() {
      if (!processingVideo || !processingCanvas || !measuring || !stream || processingVideo.paused || processingVideo.ended) return; 
      
      const video = processingVideo;
      const canvas = processingCanvas;
      const ctx = canvas.getContext('2d', { willReadFrequently: true }); 
      
      if (canvas.width !== 150 || canvas.height !== 150) {
        canvas.width = 150;
        canvas.height = 150;
      }
      
      if (video.videoWidth > 0 && video.videoHeight > 0) {
        const srcX = (video.videoWidth - canvas.width) / 2;
        const srcY = (video.videoHeight - canvas.height) / 2;
        
        ctx.drawImage(
          video, 
          srcX, srcY, canvas.width, canvas.height, // Source rectangle (center crop)
          0, 0, canvas.width, canvas.height    // Destination rectangle
        );
        
        const roiX = canvas.width / 2 - 20;
        const roiY = canvas.height / 2 - 20;
        const roiWidth = 40;
        const roiHeight = 40;

        const pixelData = ctx.getImageData(roiX, roiY, roiWidth, roiHeight).data;
        
        let totalRed = 0;
        let pixelCount = 0;
        for (let i = 0; i < pixelData.length; i += 4) {
          totalRed += pixelData[i]; 
          pixelCount++;
        }
        const avgRed = pixelCount > 0 ? totalRed / pixelCount : 0;
        
        redValuesBuffer.push(avgRed);
        
        if (redValuesBuffer.length > BUFFER_SIZE) {
          redValuesBuffer.shift();
        }
        
        dataPoints = [...redValuesBuffer];
        updateVisualization();
      }
      
      if (previewCanvas) {
        const previewCtx = previewCanvas.getContext('2d');
        previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        previewCtx.strokeStyle = 'red';
        previewCtx.lineWidth = 2;
        // Ensure ROI on preview matches processing ROI if preview is different size
        const previewRoiX = previewCanvas.width / 2 - 20; 
        const previewRoiY = previewCanvas.height / 2 - 20;
        previewCtx.strokeRect(previewRoiX, previewRoiY, 40, 40);
      }
      
      frameProcessorId = requestAnimationFrame(processFrame);
    }
    
    // Calculate heart rate from red values
    function calculateHeartRate() {
      if (redValuesBuffer.length < FPS * 3) { 
        console.warn("Not enough data to calculate heart rate.");
        return null; 
      }
      
      const mean = redValuesBuffer.reduce((sum, val) => sum + val, 0) / redValuesBuffer.length;
      const normalizedValues = redValuesBuffer.map(val => val - mean);
      
      const peaks = [];
      if (normalizedValues.length === 0) return null; // Should not happen if buffer has data
      
      const maxNormalizedValue = Math.max(...normalizedValues);
      // Ensure peakThreshold is not negative or zero if all normalizedValues are negative/zero
      const peakThreshold = maxNormalizedValue > 0 ? maxNormalizedValue * 0.3 : 0.1; 
      
      for (let i = 1; i < normalizedValues.length - 1; i++) {
        if (normalizedValues[i] > normalizedValues[i-1] && 
            normalizedValues[i] > normalizedValues[i+1] &&
            normalizedValues[i] > peakThreshold) { 
          peaks.push(i); 
        }
      }
      
      if (peaks.length < 2) {
        console.warn("Not enough peaks detected to calculate heart rate.");
        return null; 
      }
      
      let totalInterval = 0;
      for (let i = 1; i < peaks.length; i++) {
        totalInterval += peaks[i] - peaks[i-1]; 
      }
      const avgIntervalFrames = totalInterval / (peaks.length - 1); 
      
      if (avgIntervalFrames === 0) return null; // Avoid division by zero

      const heartRate = Math.round((FPS * 60) / avgIntervalFrames);
      
      if (heartRate >= 40 && heartRate <= 220) {
        return heartRate;
      } else {
        console.warn(`Calculated heart rate (${heartRate} BPM) is outside typical range.`);
        return null; 
      }
    }
    
    // Start measurement process
    async function startMeasurement() {
      measuring = true;
      countdown = 5; 
      redValuesBuffer = [];
      dataPoints = []; 
      measurementNumber = 0; 
      individualReadings = [];
      
      initialState.classList.add('hidden');
      resultsState.classList.add('hidden');
      measuringState.classList.remove('hidden');
      cameraError.classList.add('hidden'); // Hide any previous errors
      
      countdownElement.textContent = countdown;
      countdownElement.classList.add('pulse'); 
      clearVisualization();
      updateMeasurementIndicators(); 
      clearReadings();
      
      try {
        const cameraStarted = await startCameraWithFacing(cameraFacing);
        
        if (!cameraStarted) {
          stopMeasuring(); 
          initialState.classList.remove('hidden'); 
          measuringState.classList.add('hidden'); 
          // Error message is shown by startCameraWithFacing
          return; 
        }
        
        let countdownTimer = setInterval(() => {
          countdown--;
          countdownElement.textContent = countdown;
          
          if (countdown <= 0) {
            clearInterval(countdownTimer);
            countdownTimer = null; // Clear interval ID
            countdownElement.classList.remove('pulse'); 
            measurementNumber = 1; 
            startSingleMeasurement();
          }
        }, 1000);
      } catch (error) { 
        console.error('Error starting measurement process:', error);
        showCameraError('An unexpected error occurred while starting measurement.');
        stopMeasuring();
        initialState.classList.remove('hidden');
        measuringState.classList.add('hidden');
      }
    }
    
    // Start a single measurement cycle
    function startSingleMeasurement() {
      countdownElement.textContent = `${measurementNumber}/${TOTAL_MEASUREMENTS}`;
      updateMeasurementIndicators(); 
      
      redValuesBuffer = [];
      
      if (frameProcessorId) cancelAnimationFrame(frameProcessorId); 
      frameProcessorId = requestAnimationFrame(processFrame);
      
      setTimeout(() => {
        if (frameProcessorId) {
          cancelAnimationFrame(frameProcessorId);
          frameProcessorId = null;
        }
        
        const hr = calculateHeartRate();
        const newReading = (hr !== null) ? hr : FAILED_MEASUREMENT_TEXT;
        individualReadings.push(newReading);
        
        updateReadings(); 
        updateMeasurementIndicators(); 
        
        if (measurementNumber < TOTAL_MEASUREMENTS) {
          measurementNumber++; 
          setTimeout(() => {
            startSingleMeasurement();
          }, 1000); 
        } else {
          const validReadings = individualReadings.filter(r => typeof r === 'number' && r >= 40 && r <= 220);
          
          let finalHR;
          if (validReadings.length > 0) {
            const sortedReadings = [...validReadings].sort((a, b) => a - b);
            finalHR = sortedReadings[Math.floor(sortedReadings.length / 2)];
          } else {
            finalHR = FAILED_MEASUREMENT_TEXT; 
          }
          
          heartRate = finalHR; 
          
          if (typeof heartRate === 'number') {
            recommendedTempo = Math.floor(heartRate * 0.7);
            tempoValue.textContent = `${recommendedTempo} BPM`;
            currentTempo.textContent = recommendedTempo;
            startSessionBtn.disabled = false; 
            startSessionBtn.classList.remove('btn-disabled'); 
          } else {
            recommendedTempo = FAILED_MEASUREMENT_TEXT; 
            tempoValue.textContent = "N/A";
            currentTempo.textContent = "N/A";
            startSessionBtn.disabled = true; 
            startSessionBtn.classList.add('btn-disabled'); 
          }
          
          heartRateValue.textContent = (typeof heartRate === 'number') ? `${heartRate} BPM` : "Measurement Failed";
          updateResultReadings(); 
          
          measuringState.classList.add('hidden');
          resultsState.classList.remove('hidden');
          
          stopMeasuring(); 
        }
      }, MEASUREMENT_DURATION * 1000);
    }
    
    // Stop measuring and clean up
    function stopMeasuring() {
      measuring = false; 
      
      if (frameProcessorId) {
        cancelAnimationFrame(frameProcessorId);
        frameProcessorId = null;
      }
      
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null; 
      }
    }
    
    // Simulate measurement 
    function simulateMeasurement() {
      measuring = true;
      countdown = 5;
      redValuesBuffer = [];
      measurementNumber = 0; 
      individualReadings = [];
      
      initialState.classList.add('hidden');
      resultsState.classList.add('hidden');
      measuringState.classList.remove('hidden');
      cameraError.classList.add('hidden');
      
      countdownElement.textContent = countdown;
      countdownElement.classList.add('pulse');
      clearVisualization();
      updateMeasurementIndicators();
      clearReadings();
      
      let simCountdownTimer = setInterval(() => {
        countdown--;
        countdownElement.textContent = countdown;
        
        if (countdown <= 0) {
          clearInterval(simCountdownTimer);
          simCountdownTimer = null;
          countdownElement.classList.remove('pulse');
          measurementNumber = 1;
          simulateSingleMeasurement(); 
        }
      }, 1000);
    }

    function simulateSingleMeasurement() {
        countdownElement.textContent = `${measurementNumber}/${TOTAL_MEASUREMENTS}`;
        updateMeasurementIndicators();
        simulateDataPoints(); 

        setTimeout(() => {
            const success = Math.random() > 0.2; 
            const simulatedReading = success ? (Math.floor(Math.random() * 25) + 65) : FAILED_MEASUREMENT_TEXT;
            individualReadings.push(simulatedReading);

            updateReadings();
            updateMeasurementIndicators(); 

            if (measurementNumber < TOTAL_MEASUREMENTS) {
                measurementNumber++;
                setTimeout(simulateSingleMeasurement, 1000); 
            } else {
                const validReadings = individualReadings.filter(r => typeof r === 'number');
                let finalHR;
                if (validReadings.length > 0) {
                    const sortedReadings = [...validReadings].sort((a, b) => a - b);
                    finalHR = sortedReadings[Math.floor(sortedReadings.length / 2)]; 
                } else {
                    finalHR = FAILED_MEASUREMENT_TEXT;
                }
                heartRate = finalHR;

                if (typeof heartRate === 'number') {
                    recommendedTempo = Math.floor(heartRate * 0.7);
                    tempoValue.textContent = `${recommendedTempo} BPM`;
                    currentTempo.textContent = recommendedTempo;
                    startSessionBtn.disabled = false;
                    startSessionBtn.classList.remove('btn-disabled');
                } else {
                    recommendedTempo = "N/A";
                    tempoValue.textContent = "N/A";
                    currentTempo.textContent = "N/A";
                    startSessionBtn.disabled = true;
                    startSessionBtn.classList.add('btn-disabled');
                }

                heartRateValue.textContent = (typeof heartRate === 'number') ? `${heartRate} BPM` : "Measurement Failed";
                updateResultReadings();

                measuringState.classList.add('hidden');
                resultsState.classList.remove('hidden');
                // No real stream to stop in simulation, but good practice if stopMeasuring had other cleanup
                // stopMeasuring(); 
            }
        }, MEASUREMENT_DURATION * 500); 
    }
    
    // Simulate PPG data points for visualization
    function simulateDataPoints() {
      redValuesBuffer = []; 
      const baseValue = 150;
      const amplitude = 30;
      const frequency = 1.2; 
      const durationSeconds = 3; 
      const numPoints = FPS * durationSeconds;

      for (let i = 0; i < numPoints; i++) {
        const time = i / FPS; 
        const pulse = Math.sin(time * Math.PI * 2 * frequency) * amplitude;
        const noise = Math.random() * 10 - 5; 
        redValuesBuffer.push(baseValue + pulse + noise);
      }
      
      dataPoints = [...redValuesBuffer]; 
      updateVisualization(); 
      
      let animationFrameCount = 0;
      function animateSimulatedData() {
        if (!measuring || redValuesBuffer.length === 0) {
            if (frameProcessorId === simAnimationId) frameProcessorId = null; // Clean up if this was the animation
            return; 
        }

        redValuesBuffer.shift();
        const time = (numPoints + animationFrameCount) / FPS; 
        const pulse = Math.sin(time * Math.PI * 2 * frequency) * amplitude;
        const noise = Math.random() * 10 - 5;
        redValuesBuffer.push(baseValue + pulse + noise);
        
        dataPoints = [...redValuesBuffer];
        updateVisualization();
        animationFrameCount++;
        
        if (measuring) { 
          const simAnimationId = requestAnimationFrame(animateSimulatedData); 
          if (!frameProcessorId) frameProcessorId = simAnimationId; // Store to allow cancellation
        } else {
            if (frameProcessorId === simAnimationId) frameProcessorId = null;
        }
      }
      if (measuring) { 
        const simAnimationId = requestAnimationFrame(animateSimulatedData);
        frameProcessorId = simAnimationId; // Allow cancellation via frameProcessorId
      }
    }
    
    // Start meditation session
    function startMeditation() {
      if (typeof heartRate !== 'number' || meditationActive) return; 

      meditationActive = true;
      progress = 0;
      
      startSessionBtn.classList.add('hidden');
      endSessionBtn.classList.remove('hidden');
      meditationSection.classList.remove('hidden');
      progressFill.style.width = '0%';
      
      const totalMeditationDurationMs = 10 * 60 * 1000; 
      const progressUpdateIntervalMs = totalMeditationDurationMs / 100; 

      animationId = setInterval(() => {
        progress += 1;
        progressFill.style.width = `${progress}%`;
        
        if (progress >= 100) {
          endMeditation();
        }
      }, progressUpdateIntervalMs); 
    }
    
    // End meditation session
    function endMeditation() {
      meditationActive = false;
      
      startSessionBtn.classList.remove('hidden');
      endSessionBtn.classList.add('hidden');
      
      if (animationId) {
        clearInterval(animationId);
        animationId = null;
      }
    }
    
    // Update visualization display
    function updateVisualization() {
      visualization.innerHTML = ''; 
      
      const displayPoints = dataPoints.slice(-100); 
      if (displayPoints.length === 0) return; // Nothing to display

      const minVal = Math.min(...displayPoints); 
      const maxVal = Math.max(...displayPoints); 
      const range = (maxVal - minVal) === 0 ? 1 : (maxVal - minVal); 

      for (let i = 0; i < displayPoints.length; i++) {
        const value = displayPoints[i];
        const normalizedValue = ((value - minVal) / range) * 100; 
        const height = Math.max(1, Math.min(100, normalizedValue)); 
        
        const bar = document.createElement('div');
        bar.className = 'visualization-bar';
        bar.style.height = `${height}%`;
        bar.style.left = `${(i / displayPoints.length) * 100}%`; 
        bar.style.width = `${Math.max(1, 100 / displayPoints.length)}%`; // Ensure min width of 1px

        visualization.appendChild(bar);
      }
    }
    
    // Clear visualization
    function clearVisualization() {
      visualization.innerHTML = '';
      dataPoints = []; 
    }
    
    // Update readings display during measurement
    function updateReadings() {
      readings.innerHTML = ''; 
      
      individualReadings.forEach((reading) => {
        const readingElement = document.createElement('div');
        readingElement.className = 'reading';
        
        if (reading === FAILED_MEASUREMENT_TEXT) {
          readingElement.innerHTML = `<span class="reading-value">${FAILED_MEASUREMENT_TEXT}</span>`;
        } else {
          readingElement.innerHTML = `
            <span class="reading-value">${reading}</span>
            <span class="reading-unit">&nbsp;BPM</span>
          `;
        }
        readings.appendChild(readingElement);
      });
    }
    
    // Clear readings display
    function clearReadings() {
      readings.innerHTML = '';
    }
    
    // Update result readings display after all measurements
    function updateResultReadings() {
      resultReadings.innerHTML = ''; 
      
      individualReadings.forEach((reading) => {
        const readingElement = document.createElement('div');
        readingElement.className = 'result-reading';
        
        let iconSvg = '';
        let readingText = '';

        if (reading === FAILED_MEASUREMENT_TEXT) {
          iconSvg = `
            <svg class="icon icon-xs" viewBox="0 0 24 24" style="color: #ef4444; margin-right: 4px;">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          `;
          readingText = FAILED_MEASUREMENT_TEXT;
        } else {
          iconSvg = `
            <svg class="icon icon-xs" viewBox="0 0 24 24" style="color: #10b981; margin-right: 4px;">
              <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
          `;
          readingText = `${reading} BPM`;
        }
        
        readingElement.innerHTML = iconSvg + readingText;
        resultReadings.appendChild(readingElement);
      });
    }
    
    // Update measurement indicators
    function updateMeasurementIndicators() {
      const indicators = measurementIndicators.querySelectorAll('.indicator');
      
      for (let i = 0; i < indicators.length; i++) {
        indicators[i].className = 'indicator'; // Reset classes
        
        // Check if there's a reading for this indicator's measurement
        if (i < individualReadings.length) { // This measurement has been attempted
            if (individualReadings[i] === FAILED_MEASUREMENT_TEXT) {
                indicators[i].classList.add('failed');
            } else {
                indicators[i].classList.add('complete');
            }
        } else if (i === measurementNumber -1 && measuring) { // Current measurement in progress
            indicators[i].classList.add('active');
        }
        // Indicators for future measurements (i >= measurementNumber or i >= individualReadings.length if not measuring) remain default gray
      }
    }
    
    // Event listeners
    document.addEventListener('DOMContentLoaded', function() {
      checkCameras(); 
      
      startMeasurementBtn.addEventListener('click', startMeasurement);
      cameraToggle.addEventListener('click', toggleCamera);
      remeasureBtn.addEventListener('click', startMeasurement); 
      startSessionBtn.addEventListener('click', startMeditation);
      endSessionBtn.addEventListener('click', endMeditation);
    });
    
    // Clean up on page unload
    window.addEventListener('beforeunload', function() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      
      if (frameProcessorId) {
        cancelAnimationFrame(frameProcessorId);
        frameProcessorId = null;
      }
      
      if (animationId) { 
        clearInterval(animationId);
        animationId = null;
      }
    });
  </script>
</body>
</html>
